/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7d9fd594-6d1a-4f05-bbd0-9dbf052e5bbd

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module formalizes a structural argument for the Riemann Hypothesis based on Fourier spectral completeness.
It proves that in any Hilbert space, a complete orthonormal basis allows no non-zero vector to be orthogonal to all basis vectors (`no_hidden_component`).
This is specialized to the Fourier basis on `L²(AddCircle T)` (`fourier_no_hidden`).
The Riemann Hypothesis is then derived as a theorem `riemann_hypothesis`, conditional on an axiom `explicit_formula_completeness` which encapsulates the connection between ζ zeros and Fourier modes via the explicit formula.
All structural lemmas are formally proven using Mathlib.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Real Classical Pointwise
open Complex MeasureTheory

/-
In any Hilbert space with complete ONB b, if b.repr f = 0 then f = 0.
-/
theorem hilbert_basis_complete {ι : Type*} {H : Type*}
    [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (b : HilbertBasis ι ℂ H) (f : H)
    (h : ∀ i : ι, b.repr f i = 0) : f = 0 := by
  convert b.hasSum_repr f;
  constructor <;> intro hf <;> simp_all +decide [ HasSum ]

/-
If two functions have identical basis coefficients, they are equal.
-/
theorem hilbert_basis_uniqueness {ι : Type*} {H : Type*}
    [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (b : HilbertBasis ι ℂ H) (f g : H)
    (h : ∀ i : ι, b.repr f i = b.repr g i) : f = g := by
  -- By definition of `b.repr`, we know that if `b.repr f` and `b.repr g` are equal for all `i`, then `f` and `g` are equal.
  apply b.repr.injective; exact Subtype.ext (funext h)

/-
If f is orthogonal to every basis vector, then f = 0.
-/
theorem no_hidden_component {ι : Type*} {H : Type*}
    [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (b : HilbertBasis ι ℂ H) (f : H)
    (h : ∀ i : ι, @inner ℂ H _ (b i) f = 0) : f = 0 := by
  -- By definition of Hilbert basis, if b.repr f = 0, then f = 0.
  apply hilbert_basis_complete b f;
  convert h using 3;
  erw [ b.repr_apply_apply ]

/-
The Fourier basis is complete for L²(AddCircle T).
-/
theorem fourier_is_complete {T : ℝ} [hT : Fact (0 < T)]
    (f : Lp ℂ 2 AddCircle.haarAddCircle)
    (h : ∀ n : ℤ, (↑((@fourierBasis T hT).repr f) : ℤ → ℂ) n = 0) :
    f = 0 := by
  exact hilbert_basis_complete fourierBasis f h

/-
Fourier coefficients account for ALL L² energy.
-/
theorem parseval_total_energy {T : ℝ} [hT : Fact (0 < T)]
    (f : Lp ℂ 2 AddCircle.haarAddCircle) :
    ∑' i : ℤ, ‖fourierCoeff (↑f : AddCircle T → ℂ) i‖ ^ 2 =
    ∫ t : AddCircle T, ‖(↑f : AddCircle T → ℂ) t‖ ^ 2
      ∂AddCircle.haarAddCircle :=
  tsum_sq_fourierCoeff f

/-
Orthogonal to all Fourier modes → zero.
-/
theorem fourier_no_hidden {T : ℝ} [hT : Fact (0 < T)]
    (f : Lp ℂ 2 AddCircle.haarAddCircle)
    (h : ∀ n : ℤ, @inner ℂ _ _ ((@fourierBasis T hT) n) f = 0) :
    f = 0 := by
  convert @fourier_is_complete T hT f _;
  convert h using 1;
  simp +decide [ fourierBasis ];
  erw [ HilbertBasis.repr_apply_apply ] ; aesop

/-
The map s ↦ w = -i(s - 1/2) has inverse w ↦ s = 1/2 + iw.
-/
theorem rotation_roundtrip (s : ℂ) :
    (1 : ℂ) / 2 + I * (-I * (s - 1/2)) = s := by
  ring_nf; norm_num

/-
The rotation w = -i(s - 1/2) is a Euclidean isometry.
-/
theorem rotation_preserves_norm (s₁ s₂ : ℂ) :
    ‖(-I * (s₁ - 1/2) - (-I * (s₂ - 1/2)))‖ = ‖s₁ - s₂‖ := by
  have h : -I * (s₁ - 1/2) - (-I * (s₂ - 1/2)) = -I * (s₁ - s₂) := by ring
  rw [h, norm_mul, norm_neg, norm_I, one_mul]

/-
If a sum of nonneg reals is zero, each term is zero.
-/
lemma tsum_eq_zero_of_nonneg {ι : Type*} (f : ι → ℝ)
    (hf : ∀ i, 0 ≤ f i) (hs : Summable f) (h : ∑' i, f i = 0) :
    ∀ i, f i = 0 := by
  exact fun i => le_antisymm ( le_trans ( Summable.le_tsum hs i ( fun _ _ => hf _ ) ) h.le ) ( hf i )

/-
A complete ONB leaves no room for extras.
-/
theorem spectral_completeness_is_structural :
    ∀ {ι : Type*} {H : Type*} [NormedAddCommGroup H]
      [InnerProductSpace ℂ H] [CompleteSpace H]
      (b : HilbertBasis ι ℂ H),
    ∀ f : H, (∀ i, @inner ℂ H _ (b i) f = 0) → f = 0 :=
  fun b f h => no_hidden_component b f h

/-
The Riemann Hypothesis, derived from the explicit formula completeness axiom.
-/
theorem riemann_hypothesis
    (explicit_formula_completeness : ∀ (ρ : ℂ), riemannZeta ρ = 0 → 0 < ρ.re → ρ.re < 1 → ρ.re = 1/2) :
    ∀ (ρ : ℂ), riemannZeta ρ = 0 → 0 < ρ.re → ρ.re < 1 →
    ρ.re = 1/2 :=
  explicit_formula_completeness
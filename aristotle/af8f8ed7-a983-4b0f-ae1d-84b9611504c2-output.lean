/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: af8f8ed7-a983-4b0f-ae1d-84b9611504c2

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of Fourier spectral completeness and its structural implications for the Riemann Hypothesis.

Key theorems proved:
- `hilbert_basis_complete`: A function with zero coefficients in a complete basis is zero.
- `no_hidden_component`: A function orthogonal to a complete basis is zero.
- `fourier_is_complete`: The Fourier basis on L²(AddCircle) is complete.
- `rotation_preserves_norm`: The map s ↦ -i(s - 1/2) is an isometry.
- `spectral_completeness_is_structural`: Structural completeness leaves no room for hidden components.

All requested theorems have been formally proven.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Real Classical Pointwise
open Complex MeasureTheory

/-
In any Hilbert space with complete ONB b, if b.repr f = 0 then f = 0.
-/
theorem hilbert_basis_complete {ι : Type*} {H : Type*}
    [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (b : HilbertBasis ι ℂ H) (f : H)
    (h : ∀ i : ι, b.repr f i = 0) : f = 0 := by
  convert b.hasSum_repr f;
  -- Since each term in the sum is zero, the sum itself must be zero.
  have h_sum_zero : HasSum (fun i => 0 • b i) 0 := by
    simp +decide [ hasSum_zero ];
  convert h_sum_zero.unique _;
  rotate_left;
  exact 0;
  · convert h_sum_zero using 1;
  · simp +decide [ h ];
    exact ⟨ fun hf => by simpa [ hf ] using hasSum_zero, fun hf => by simpa using hf.unique ( hasSum_zero ) ⟩

/-
If two functions have identical basis coefficients, they are equal.
-/
theorem hilbert_basis_uniqueness {ι : Type*} {H : Type*}
    [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (b : HilbertBasis ι ℂ H) (f g : H)
    (h : ∀ i : ι, b.repr f i = b.repr g i) : f = g := by
  convert b.repr.injective _;
  ext i;
  exact h i

/-
If f is orthogonal to every basis vector, then f = 0.
-/
theorem no_hidden_component {ι : Type*} {H : Type*}
    [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (b : HilbertBasis ι ℂ H) (f : H)
    (h : ∀ i : ι, @inner ℂ H _ (b i) f = 0) : f = 0 := by
  -- By definition of Hilbert basis, if b.repr f = 0, then f = 0.
  apply hilbert_basis_complete b f;
  simp_all +decide [ b.repr_apply_apply ]

/-
The Fourier basis {e^{2πint/T}} is a HilbertBasis for L²(AddCircle T).
-/
theorem fourier_is_complete {T : ℝ} [hT : Fact (0 < T)]
    (f : Lp ℂ 2 AddCircle.haarAddCircle)
    (h : ∀ n : ℤ, (↑((@fourierBasis T hT).repr f) : ℤ → ℂ) n = 0) :
    f = 0 := by
  -- Apply the fact that if the representation of f in the Fourier basis is zero, then f must be zero.
  apply hilbert_basis_uniqueness fourierBasis f 0; aesop

/-
Fourier coefficients account for ALL L² energy.
-/
theorem parseval_total_energy {T : ℝ} [hT : Fact (0 < T)]
    (f : Lp ℂ 2 AddCircle.haarAddCircle) :
    ∑' i : ℤ, ‖fourierCoeff (↑f : AddCircle T → ℂ) i‖ ^ 2 =
    ∫ t : AddCircle T, ‖(↑f : AddCircle T → ℂ) t‖ ^ 2
      ∂AddCircle.haarAddCircle :=
  tsum_sq_fourierCoeff f

/-
Orthogonal to all Fourier modes → zero.
-/
theorem fourier_no_hidden {T : ℝ} [hT : Fact (0 < T)]
    (f : Lp ℂ 2 AddCircle.haarAddCircle)
    (h : ∀ n : ℤ, @inner ℂ _ _ ((@fourierBasis T hT) n) f = 0) :
    f = 0 := by
  convert fourier_is_complete f _;
  convert h using 1;
  rw [ fourierBasis.repr_apply_apply ]

/-
The map s ↦ w = -i(s - 1/2) has inverse w ↦ s = 1/2 + iw.
-/
theorem rotation_roundtrip (s : ℂ) :
    (1 : ℂ) / 2 + I * (-I * (s - 1/2)) = s := by
  ring_nf; norm_num

/-
The rotation w = -i(s - 1/2) is a Euclidean isometry.
-/
theorem rotation_preserves_norm (s₁ s₂ : ℂ) :
    ‖(-I * (s₁ - 1/2) - (-I * (s₂ - 1/2)))‖ = ‖s₁ - s₂‖ := by
  norm_num [ neg_add_eq_sub, Complex.normSq, Complex.norm_def ] ; ring;

/-
If a sum of nonneg reals is zero, each term is zero.
-/
lemma tsum_eq_zero_of_nonneg {ι : Type*} (f : ι → ℝ)
    (hf : ∀ i, 0 ≤ f i) (hs : Summable f) (h : ∑' i, f i = 0) :
    ∀ i, f i = 0 := by
  exact fun i => le_antisymm ( le_trans ( Summable.le_tsum hs i ( fun j _ => hf j ) ) h.le ) ( hf i )

/-
The orthogonal complement of a complete basis is trivial.
-/
theorem spectral_completeness_is_structural :
    -- For any Hilbert space with complete ONB...
    ∀ {ι : Type*} {H : Type*} [NormedAddCommGroup H]
      [InnerProductSpace ℂ H] [CompleteSpace H]
      (b : HilbertBasis ι ℂ H),
    -- ...the orthogonal complement of the basis is trivial.
    ∀ f : H, (∀ i, @inner ℂ H _ (b i) f = 0) → f = 0 :=
  fun b f h => no_hidden_component b f h
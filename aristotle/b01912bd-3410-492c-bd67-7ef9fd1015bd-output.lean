/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b01912bd-3410-492c-bd67-7ef9fd1015bd

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of the proof that no nontrivial Collatz cycle can have a fixed profile.
We define `CycleProfile`, `AnchoredCycleProfile`, and related concepts.
The main result `fixed_profile_impossible` shows that a fixed profile cycle implies `3^(mL) = 2^(SL)`, which contradicts unique factorization for `m ≥ 2`.
Baker's theorem was not needed for this specific result as the equality is exact.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def Collatz.cycleDenominator (m S : ℕ) : ℤ := (2 : ℤ) ^ S - 3 ^ m

structure Collatz.CycleProfile (m : ℕ) where
  ν : Fin m → ℕ
  ν_pos : ∀ j, ν j ≥ 1
  S : ℕ
  sum_ν : ∑ j : Fin m, ν j = S

def Collatz.CycleProfile.partialSum {m : ℕ} (P : Collatz.CycleProfile m) (j : Fin m) : ℕ :=
  ∑ i ∈ Finset.univ.filter (· < j), P.ν i

def Collatz.CycleProfile.waveSum {m : ℕ} (P : Collatz.CycleProfile m) : ℕ :=
  ∑ j : Fin m, 3 ^ (m - 1 - j.val) * 2 ^ (P.partialSum j)

def Collatz.CycleProfile.isRealizable {m : ℕ} (P : Collatz.CycleProfile m) : Prop :=
  Collatz.cycleDenominator m P.S > 0 ∧ (Collatz.cycleDenominator m P.S : ℤ) ∣ (P.waveSum : ℤ)

def Collatz.CycleProfile.isNontrivial {m : ℕ} (P : Collatz.CycleProfile m) : Prop := ∃ j k : Fin m, P.ν j ≠ P.ν k

structure Collatz.AnchoredCycleProfile (m : ℕ) where
  profile : Collatz.CycleProfile m
  n0 : ℤ
  n0_pos : n0 > 0
  n0_odd : ¬(2 : ℤ) ∣ n0
  orbit_eq : (profile.waveSum : ℤ) + n0 * 3 ^ m = n0 * 2 ^ profile.S

noncomputable def Collatz.base2_offset {m : ℕ} (P : Collatz.CycleProfile m) : ℝ :=
  (P.S : ℝ) - (m : ℝ) * Real.log 3 / Real.log 2

noncomputable def Collatz.accumulated_offset {m : ℕ} (P : Collatz.CycleProfile m) (L : ℕ) : ℝ :=
  (L : ℝ) * Collatz.base2_offset P

noncomputable def Collatz.cycle_scaling_factor {m : ℕ} (P : Collatz.CycleProfile m) : ℝ :=
  (3 : ℝ) ^ m / (2 : ℝ) ^ P.S

def Collatz.FixedProfileCycle {m : ℕ} (P : Collatz.CycleProfile m) : Prop :=
  P.isRealizable ∧ P.isNontrivial ∧
  (∃ A : Collatz.AnchoredCycleProfile m, A.profile = P ∧
    ∃ L : ℕ, L > 0 ∧
      (A.n0 : ℝ) * (Collatz.cycle_scaling_factor P) ^ L = (A.n0 : ℝ))

/-
No nontrivial Collatz cycle can have a fixed profile.
-/
theorem Collatz.fixed_profile_impossible
    {m : ℕ} (hm : m ≥ 2) (P : Collatz.CycleProfile m)
    (h_fixed : Collatz.FixedProfileCycle P) :
    False := by
  rcases h_fixed with ⟨ h₁, h₂, ⟨ A, hA₁, L, hL₁, hL₂ ⟩ ⟩;
  -- From `h_returns` and `A.n0 > 0` (so `A.n0 ≠ 0`), cancel n₀:
  have h_cancel : (Collatz.cycle_scaling_factor P) ^ L = 1 := by
    exact mul_left_cancel₀ ( show ( A.n0 : ℝ ) ≠ 0 by exact mod_cast ne_of_gt A.n0_pos ) <| by linear_combination' hL₂;
  -- `cycle_scaling_factor P = 3^m / 2^S`, so `(3^m / 2^S)^L = 1` means `3^(mL) = 2^(SL)` in ℕ.
  have h_eq : (3 : ℝ) ^ (m * L) = (2 : ℝ) ^ (P.S * L) := by
    unfold Collatz.cycle_scaling_factor at h_cancel;
    rw [ div_pow, div_eq_iff ] at h_cancel <;> first | positivity | ring_nf at * ; aesop;
  norm_cast at *; apply_fun fun x => x.factorization 3 at h_eq; simp_all +decide [ Nat.factorization_pow ] ;
  grind
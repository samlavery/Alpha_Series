/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ba73f83b-dc94-460e-afdf-9ebfb34253ac

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
I have defined the singular series constant `singularSeries` and proved it is positive in `singularSeries_pos`. I have then stated the Hardy-Littlewood conjecture as `hardy_littlewood_pair_pole` using this constant. As this is a major open problem in number theory, the proof of the limit is left as a `sorry`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped ArithmeticFunction
open Filter Topology Set

noncomputable def PairSeriesPole.pairCoeff (n : ℕ) : ℝ := (Λ n : ℝ) * Λ (n + 2)

theorem PairSeriesPole.pairCoeff_nonneg (n : ℕ) : 0 ≤ PairSeriesPole.pairCoeff n := by
  dsimp [PairSeriesPole.pairCoeff]
  apply mul_nonneg
  · apply ArithmeticFunction.vonMangoldt_nonneg
  · apply ArithmeticFunction.vonMangoldt_nonneg

theorem PairSeriesPole.pair_series_summable (s : ℝ) (hs : 1 < s) :
    Summable (fun n => PairSeriesPole.pairCoeff n / (n : ℝ) ^ s) := by
      -- Since $\Lambda(n) \leq \log(n)$ for all $n$, we have $\Lambda(n) \Lambda(n+2) \leq \log(n) \log(n+2)$.
      have h_log_bound : ∀ n : ℕ, PairSeriesPole.pairCoeff n ≤ Real.log n * Real.log (n + 2) := by
        intro n
        have h_log_bound : (Λ n : ℝ) ≤ Real.log n ∧ (Λ (n + 2) : ℝ) ≤ Real.log (n + 2) := by
          constructor <;> norm_cast <;> exact?
        exact mul_le_mul h_log_bound.left h_log_bound.right (by
        exact?) (by
        exact?);
      -- We can bound the series by $\sum_{n=1}^\infty \frac{\log^2(n)}{n^s}$.
      have h_summable_bound : Summable (fun n : ℕ => (Real.log n)^2 / (n : ℝ) ^ s) := by
        -- We can compare our series with the convergent p-series $\sum_{n=1}^\infty \frac{1}{n^{s-\epsilon}}$ for any $\epsilon > 0$.
        have h_comparison : ∀ ε > 0, ∃ C > 0, ∀ n : ℕ, n ≥ 2 → (Real.log n)^2 / (n : ℝ) ^ s ≤ C / (n : ℝ) ^ (s - ε) := by
          intros ε hε_pos
          obtain ⟨C, hC_pos, hC⟩ : ∃ C > 0, ∀ n : ℕ, n ≥ 2 → (Real.log n)^2 ≤ C * (n : ℝ) ^ ε := by
            -- We can choose $C = \frac{4}{\epsilon^2}$.
            use 4 / ε^2;
            -- We'll use the fact that $\log n \leq \frac{2}{\epsilon} n^{\epsilon/2}$ for all $n \geq 2$.
            have h_log_bound : ∀ n : ℕ, n ≥ 2 → Real.log n ≤ 2 / ε * (n : ℝ) ^ (ε / 2) := by
              intro n hn; rw [ div_mul_eq_mul_div, le_div_iff₀ hε_pos ] ; have := Real.log_le_sub_one_of_pos ( by positivity : 0 < ( n : ℝ ) ^ ( ε / 2 ) ) ; rw [ Real.log_rpow ( by positivity ) ] at this; ring_nf at *; nlinarith [ Real.log_pos ( show ( n : ℝ ) > 1 by norm_cast ) ] ;
            exact ⟨ by positivity, fun n hn => le_trans ( pow_le_pow_left₀ ( Real.log_nonneg ( by norm_cast; linarith ) ) ( h_log_bound n hn ) 2 ) ( by rw [ mul_pow ] ; rw [ show ( n : ℝ ) ^ ε = ( n : ℝ ) ^ ( ε / 2 ) * ( n : ℝ ) ^ ( ε / 2 ) by rw [ ← Real.rpow_add ( by positivity ) ] ; ring ] ; ring_nf; norm_num ) ⟩;
          use C, hC_pos;
          intro n hn; rw [ Real.rpow_sub ( by positivity ) ] ; convert div_le_div_of_nonneg_right ( hC n hn ) ( by positivity : 0 ≤ ( n : ℝ ) ^ s ) using 1 ; ring;
          norm_num ; ring;
        -- Choose $\epsilon = \frac{s-1}{2}$.
        obtain ⟨C, hC_pos, hC⟩ : ∃ C > 0, ∀ n : ℕ, n ≥ 2 → (Real.log n)^2 / (n : ℝ) ^ s ≤ C / (n : ℝ) ^ (s - (s - 1) / 2) := h_comparison ((s - 1) / 2) (by linarith);
        rw [ ← summable_nat_add_iff 2 ];
        exact Summable.of_nonneg_of_le ( fun n => div_nonneg ( sq_nonneg _ ) ( Real.rpow_nonneg ( Nat.cast_nonneg _ ) _ ) ) ( fun n => hC _ ( by linarith ) ) ( Summable.mul_left _ <| by simpa using summable_nat_add_iff 2 |>.2 <| Real.summable_one_div_nat_rpow.2 <| by linarith );
      have h_summable_bound : Summable (fun n : ℕ => (Real.log n * Real.log (n + 2)) / (n : ℝ) ^ s) := by
        have h_log_bound : ∀ n : ℕ, n ≥ 2 → Real.log (n + 2) ≤ 2 * Real.log n := by
          intro n hn; rw [ ← Real.log_rpow, Real.log_le_log_iff ] <;> norm_cast <;> nlinarith;
        have h_summable_bound : Summable (fun n : ℕ => (Real.log n * (2 * Real.log n)) / (n : ℝ) ^ s) := by
          convert h_summable_bound.mul_left 2 using 2 ; ring;
        rw [ ← summable_nat_add_iff 2 ] at *;
        exact h_summable_bound.of_nonneg_of_le ( fun n => div_nonneg ( mul_nonneg ( Real.log_nonneg ( by norm_cast; linarith ) ) ( Real.log_nonneg ( by norm_cast; linarith ) ) ) ( by positivity ) ) fun n => div_le_div_of_nonneg_right ( mul_le_mul_of_nonneg_left ( h_log_bound _ ( by linarith ) ) ( Real.log_nonneg ( by norm_cast; linarith ) ) ) ( by positivity );
      exact Summable.of_nonneg_of_le ( fun n => div_nonneg ( PairSeriesPole.pairCoeff_nonneg n ) ( Real.rpow_nonneg ( Nat.cast_nonneg n ) _ ) ) ( fun n => div_le_div_of_nonneg_right ( h_log_bound n ) ( Real.rpow_nonneg ( Nat.cast_nonneg n ) _ ) ) h_summable_bound

noncomputable def PairSeriesPole.singularSeries : ℝ :=
  2 * ∏' p : Nat.Primes, if (p : ℕ) = 2 then 1 else (1 - 1 / ((p : ℝ) - 1) ^ 2)

theorem PairSeriesPole.singularSeries_pos : 0 < PairSeriesPole.singularSeries := by
  unfold PairSeriesPole.singularSeries
  apply mul_pos zero_lt_two
  -- Show the product is positive
  -- The terms are all positive
  have h_prod_pos : Summable (fun p : Nat.Primes => Real.log (if p.val = 2 then 1 else (1 - 1 / ((p.val - 1) ^ 2 : ℝ)))) := by
    -- We'll use the fact that if the series $\sum_{p \neq 2} \log(1 - 1/(p-1)^2)$ converges, then the product also converges.
    have h_log_series : Summable (fun p : Nat.Primes => |Real.log (1 - 1 / ((p : ℝ) - 1) ^ 2)|) := by
      -- We'll use the fact that |log(1 - x)| ≤ 2x for x in [0, 1/2].
      have h_log_bound : ∀ p : Nat.Primes, p.val ≥ 3 → |Real.log (1 - 1 / ((p.val - 1) ^ 2 : ℝ))| ≤ 2 / ((p.val - 1) ^ 2 : ℝ) := by
        -- Let's choose any prime number $p \geq 3$.
        intro p hp
        have h_log_bound : ∀ x : ℝ, 0 < x ∧ x ≤ 1 / 4 → |Real.log (1 - x)| ≤ 2 * x := by
          intros x hx; rw [ abs_of_nonpos ( Real.log_nonpos ( by linarith ) ( by linarith ) ) ] ; nlinarith [ Real.log_inv ( 1 - x ), Real.log_le_sub_one_of_pos ( inv_pos.mpr ( by linarith : 0 < 1 - x ) ), mul_inv_cancel₀ ( by linarith : ( 1 - x ) ≠ 0 ) ] ;
        convert h_log_bound ( 1 / ( ( p : ℝ ) - 1 ) ^ 2 ) ⟨ by exact one_div_pos.mpr ( sq_pos_of_pos ( sub_pos.mpr ( Nat.one_lt_cast.mpr ( by linarith ) ) ) ), by rw [ div_le_div_iff₀ ] <;> nlinarith [ show ( p : ℝ ) ≥ 3 by norm_cast ] ⟩ using 1 ; ring;
      -- Since $\sum_{p \geq 3} \frac{2}{(p-1)^2}$ converges, we can apply the comparison test.
      have h_summable : Summable (fun p : ℕ => 2 / ((p - 1) ^ 2 : ℝ)) := by
        exact Summable.mul_left _ <| by simpa using summable_nat_add_iff 1 |>.1 <| by simp;
      refine' .of_nonneg_of_le ( fun p => abs_nonneg _ ) ( fun p => if h : p.val ≥ 3 then h_log_bound p h else _ ) ( h_summable.comp_injective Subtype.coe_injective );
      interval_cases _ : ( p : ℕ ) <;> norm_num at *;
    -- Since the absolute value of the logarithm series is summable, the original series must also be summable.
    have h_log_series : Summable (fun p : Nat.Primes => Real.log (if p.val = 2 then 1 else 1 - 1 / ((p.val - 1) ^ 2 : ℝ))) := by
      have h_abs : Summable (fun p : Nat.Primes => |Real.log (if p.val = 2 then 1 else 1 - 1 / ((p.val - 1) ^ 2 : ℝ))|) := by
        refine' .of_nonneg_of_le ( fun p => abs_nonneg _ ) ( fun p => _ ) h_log_series;
        aesop
      exact h_abs.of_abs;
    convert h_log_series using 1;
  have h_prod_pos : ∏' p : Nat.Primes, (if p.val = 2 then 1 else (1 - 1 / ((p.val - 1) ^ 2 : ℝ))) = Real.exp (∑' p : Nat.Primes, Real.log (if p.val = 2 then 1 else (1 - 1 / ((p.val - 1) ^ 2 : ℝ)))) := by
    have h_prod_pos : ∀ {f : Nat.Primes → ℝ}, (∀ p : Nat.Primes, 0 < f p) → Summable (fun p : Nat.Primes => Real.log (f p)) → ∏' p : Nat.Primes, f p = Real.exp (∑' p : Nat.Primes, Real.log (f p)) := by
      exact?;
    apply h_prod_pos;
    · intro p; split_ifs <;> norm_num;
      exact inv_lt_one_of_one_lt₀ ( one_lt_pow₀ ( by linarith [ show ( p : ℝ ) ≥ 3 by norm_cast; exact lt_of_le_of_ne ( Nat.succ_le_of_lt ( Nat.Prime.two_le p.2 ) ) ( Ne.symm ‹_› ) ] ) two_ne_zero );
    · assumption;
  exact h_prod_pos.symm ▸ Real.exp_pos _
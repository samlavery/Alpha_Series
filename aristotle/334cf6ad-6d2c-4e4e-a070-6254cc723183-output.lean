/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 334cf6ad-6d2c-4e4e-a070-6254cc723183

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the necessary structures for Collatz cycle profiles, including `CycleProfile`, `AnchoredCycleProfile`, and the `FixedProfileCycle` predicate. We then state the main theorem `fixed_profile_impossible`, which asserts that no nontrivial fixed-profile cycle exists. The ATP successfully proves this theorem by deriving a contradiction from the cycle scaling factor condition: the definition of `FixedProfileCycle` implies `(3^m / 2^S)^L = 1`, which leads to `3^(mL) = 2^(LS)`. By unique factorization, this requires `mL = 0`, contradicting `m ≥ 2` and `L > 0`. This direct proof avoids the need for the provided Baker's theorem axiom, although the axiom was included in the context.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def cycleDenominator (m S : ℕ) : ℤ := (2 : ℤ) ^ S - 3 ^ m

structure CycleProfile (m : ℕ) where
  ν : Fin m → ℕ
  ν_pos : ∀ j, ν j ≥ 1
  S : ℕ
  sum_ν : ∑ j : Fin m, ν j = S

def CycleProfile.partialSum {m : ℕ} (P : CycleProfile m) (j : Fin m) : ℕ :=
  ∑ i ∈ Finset.univ.filter (· < j), P.ν i

def CycleProfile.waveSum {m : ℕ} (P : CycleProfile m) : ℕ :=
  ∑ j : Fin m, 3 ^ (m - 1 - j.val) * 2 ^ (P.partialSum j)

def CycleProfile.isRealizable {m : ℕ} (P : CycleProfile m) : Prop :=
  cycleDenominator m P.S > 0 ∧ (cycleDenominator m P.S : ℤ) ∣ (P.waveSum : ℤ)

def CycleProfile.isNontrivial {m : ℕ} (P : CycleProfile m) : Prop := ∃ j k : Fin m, P.ν j ≠ P.ν k

structure AnchoredCycleProfile (m : ℕ) where
  profile : CycleProfile m
  n0 : ℤ
  n0_pos : n0 > 0
  n0_odd : ¬(2 : ℤ) ∣ n0
  orbit_eq : (profile.waveSum : ℤ) + n0 * 3 ^ m = n0 * 2 ^ profile.S

noncomputable def base2_offset {m : ℕ} (P : CycleProfile m) : ℝ :=
  (P.S : ℝ) - (m : ℝ) * Real.log 3 / Real.log 2

noncomputable def accumulated_offset {m : ℕ} (P : CycleProfile m) (L : ℕ) : ℝ :=
  (L : ℝ) * base2_offset P

noncomputable def cycle_scaling_factor {m : ℕ} (P : CycleProfile m) : ℝ :=
  (3 : ℝ) ^ m / (2 : ℝ) ^ P.S

def FixedProfileCycle {m : ℕ} (P : CycleProfile m) : Prop :=
  P.isRealizable ∧ P.isNontrivial ∧
  (∃ A : AnchoredCycleProfile m, A.profile = P ∧
    ∃ L : ℕ, L > 0 ∧
      (A.n0 : ℝ) * (cycle_scaling_factor P) ^ L = (A.n0 : ℝ))

def BakerLowerBound : Prop :=
  ∀ {m : ℕ} (P : CycleProfile m) (hm : m ≥ 2) (hnontrivial : P.isNontrivial),
    ∃ δ : ℝ, δ > 0 ∧ |((P.S : ℝ) - (m : ℝ) * Real.log 3 / Real.log 2)| ≥ δ / m

/-
No nontrivial Collatz cycle can have a fixed profile. Baker's theorem implies a drift that prevents the orbit from closing.
-/
theorem fixed_profile_impossible
    {m : ℕ} (hm : m ≥ 2) (P : CycleProfile m)
    (h_fixed : FixedProfileCycle P)
    (baker : BakerLowerBound) :
    False := by
      -- From `h_fixed`, we have that there exists an � anchored� profile `A` and a cycle count `L > 0` such that `A.n0 * (cycle_scaling_factor P)^L = A.n0`.
      obtain ⟨A, LA, hLA_pos, hLA_eq⟩ := h_fixed;
      -- Since `A.n0 > 0`, we cancel `A.n0` to get `(cycle_scaling_factor P)^L = 1`.
      obtain ⟨L, hL_pos, hL_eq⟩ := hLA_eq.right;
      have hL_eq_one : (cycle_scaling_factor P) ^ L = 1 := by
        exact mul_left_cancel₀ ( show ( hLA_pos.n0 : ℝ ) ≠ 0 from mod_cast hLA_pos.n0_pos.ne' ) <| by linear_combination hL_eq;
      have h_base2_offset_zero : (3 : ℝ) ^ (m * L) = (2 : ℝ) ^ (L * P.S) := by
        unfold cycle_scaling_factor at hL_eq_one;
        rw [ div_pow, div_eq_iff ] at hL_eq_one <;> first | positivity | ring_nf at * ; aesop;
      norm_cast at *;
      apply_fun fun x => x.factorization 3 at h_base2_offset_zero ; simp_all +decide [ pos_iff_ne_zero ]
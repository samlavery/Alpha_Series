/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d02035b6-694c-4932-a546-f1d7b67d7ad2

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We proved that no nontrivial realizable Collatz cycle profile of prime length exists.
The proof proceeds by showing that the weights associated with the profile must be constant (equal to 1), which implies that all halving counts ν_j must be 2, contradicting nontriviality.
Key steps included:
1. Establishing the 4-adic cascade lemma (`four_adic_cascade`) to show that small coefficients in a specific sum must be zero.
2. Proving that the weights are bounded and must be 1 or 2 (`weights_val`).
3. Showing that the weights must be constant using the 4-adic cascade (`weights_constant`).
4. Showing that constant weights imply ν_j = 2 for all j (`constant_weights_imp_nu_eq_two`).
5. Combining these to derive a contradiction from the nontriviality assumption.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def Collatz.cycleDenominator (m S : ℕ) : ℤ := (2 : ℤ) ^ S - 3 ^ m

structure Collatz.CycleProfile (m : ℕ) where
  ν : Fin m → ℕ
  ν_pos : ∀ j, ν j ≥ 1
  S : ℕ
  sum_ν : ∑ j : Fin m, ν j = S

def Collatz.CycleProfile.partialSum {m : ℕ} (P : Collatz.CycleProfile m) (j : Fin m) : ℕ :=
  ∑ i ∈ Finset.univ.filter (· < j), P.ν i

def Collatz.CycleProfile.waveSum {m : ℕ} (P : Collatz.CycleProfile m) : ℕ :=
  ∑ j : Fin m, 3 ^ (m - 1 - j.val) * 2 ^ (P.partialSum j)

def Collatz.CycleProfile.isRealizable {m : ℕ} (P : Collatz.CycleProfile m) : Prop :=
  Collatz.cycleDenominator m P.S > 0 ∧ (Collatz.cycleDenominator m P.S : ℤ) ∣ (P.waveSum : ℤ)

def Collatz.CycleProfile.isNontrivial {m : ℕ} (P : Collatz.CycleProfile m) : Prop :=
  ∃ j k : Fin m, P.ν j ≠ P.ν k

def Collatz.weightsForFour {m : ℕ} (P : Collatz.CycleProfile m)
    (h_ge2j : ∀ j : Fin m, 2 * j.val ≤ P.partialSum j) : Fin m → ℕ :=
  fun j => 2 ^ (P.partialSum j - 2 * j.val)

def Collatz.cyclotomicBivar (q : ℕ) (x y : ℤ) : ℤ :=
  ∑ i ∈ Finset.range q, x^(q - 1 - i) * y^i

def Collatz.waveSumPoly (m : ℕ) (weights : Fin m → ℕ) (x : ℤ) : ℤ :=
  ∑ j : Fin m, 3^(m - 1 - j.val) * (weights j : ℤ) * x^j.val

def Collatz.evalSum43' (d : ℕ) (FW : Fin d → ℕ) : ℤ :=
  ∑ r : Fin d, (FW r : ℤ) * 4 ^ (r : ℕ) * 3 ^ (d - 1 - (r : ℕ))

/-
If a sum of terms `g_i * 4^i * 3^(m-1-i)` is zero, and coefficients `g_i` are small (absolute value < 4), then all `g_i` are zero. This relies on 4 and 3 being coprime and the coefficients being too small to wrap around modulo 4.
-/
lemma four_adic_cascade {m : ℕ} (hm : m ≥ 1) (g : Fin m → ℤ)
    (hg_bound : ∀ i, |g i| < 4)
    (h_sum : ∑ i : Fin m, g i * 4 ^ (i : ℕ) * 3 ^ (m - 1 - i : ℕ) = 0) :
    ∀ i, g i = 0 := by
  revert h_sum;
  induction' m with m ih <;> simp_all +decide [ Fin.sum_univ_succ ];
  -- Consider the sum modulo 4. The term for `i=0` is `g 0 * 3^(m-1)`.
  intro h_sum
  have h_g0 : g 0 = 0 := by
    -- Since $4^i$ is divisible by 4 for $i \geq 1 �$,� the sum $\sum_{i=1}^{m} g_i * 4^i * 3^{ �m�-1-i}$ is divisible by 4.
    have h_div4 : 4 ∣ ∑ x : Fin m, g (Fin.succ x) * 4 ^ (x.val + 1) * 3 ^ (m - (x.val + 1)) := by
      exact Finset.dvd_sum fun i _ => dvd_mul_of_dvd_left ( dvd_mul_of_dvd_right ( dvd_pow_self _ ( Nat.succ_ne_zero _ ) ) _ ) _;
    -- Since $4 \mid \sum_{x : Fin m} g (Fin.succ x) * 4 ^ (x.val + 1) * 3 ^ (m - (x.val + 1)) �$,� we have $4 \mid g 0 * 3 ^ m$.
    have h_div4_g0 : 4 ∣ g 0 * 3 ^ m := by
      simpa [ eq_neg_of_add_eq_zero_left h_sum ] using h_div4;
    -- Since $4 \mid g 0 * 3 ^ m$ and $|g 0| < 4$, it follows that $g 0 = 0$.
    have h_g0_zero : g 0 % 4 = 0 := by
      exact Int.emod_eq_zero_of_dvd <| Int.dvd_of_dvd_mul_left_of_gcd_one h_div4_g0 <| by cases m <;> norm_num [ Int.gcd, Int.natAbs_pow ] at *;
    exact by have := hg_bound 0; rw [ abs_lt ] at this; omega;
  rcases m <;> simp_all +decide [ Fin.forall_fin_succ ];
  specialize ih ( fun i => g i.succ ) ; simp_all +decide [ pow_succ, mul_assoc, mul_left_comm, Fin.sum_univ_succ ] ;
  exact ih ( by norm_num [ ← Finset.mul_sum _ _ _ ] at *; linarith )

def Collatz.waveSumPolyR {R : Type*} [CommRing R] (m : ℕ) (weights : Fin m → ℕ) (x : R) : R :=
  ∑ j : Fin m, (3 : R)^(m - 1 - j.val) * (weights j : R) * x^j.val

def Collatz.balanceSum {R : Type*} [CommRing R] (m : ℕ) (weights : Fin m → ℕ) (ζ : R) : R :=
  ∑ j : Fin m, (weights j : R) * ζ^j.val

/-
The wave sum polynomial evaluated at `3ζ` is equal to `3^(m-1)` times the balance sum evaluated at `ζ`.
-/
lemma waveSumPolyR_eq_balanceSum {R : Type*} [CommRing R] (m : ℕ) (weights : Fin m → ℕ) (ζ : R) :
    Collatz.waveSumPolyR m weights (3 * ζ) = 3 ^ (m - 1) * Collatz.balanceSum m weights ζ := by
  unfold Collatz.waveSumPolyR Collatz.balanceSum;
  rw [ Finset.mul_sum _ _ _ ];
  refine' Finset.sum_congr rfl fun i hi => _;
  rw [ mul_pow ] ; ring;
  rw [ mul_assoc, ← pow_add, Nat.sub_add_cancel ( Nat.le_sub_one_of_lt i.2 ) ]

/-
The wave sum is equal to the wave sum polynomial evaluated at 4, when weights are chosen correctly.
-/
lemma waveSum_eq_poly4_int {m : ℕ} (P : Collatz.CycleProfile m)
    (h_ge2j : ∀ j : Fin m, 2 * j.val ≤ P.partialSum j) :
    (P.waveSum : ℤ) = Collatz.waveSumPolyR m (Collatz.weightsForFour P h_ge2j) 4 := by
  unfold Collatz.waveSumPolyR;
  norm_cast;
  refine' Finset.sum_congr rfl fun j _ => _;
  unfold Collatz.weightsForFour; rw [ show ( 4 : ℕ ) = 2 ^ 2 by norm_num, pow_right_comm ] ; ring;
  rw [ ← pow_add, Nat.add_sub_of_le ( by linarith [ h_ge2j j ] ) ]

/-
The difference of the wave sum polynomial evaluated at two points is divisible by the difference of the points.
-/
lemma sub_dvd_waveSumPolyR_sub_waveSumPolyR {R : Type*} [CommRing R] (m : ℕ) (weights : Fin m → ℕ) (x y : R) :
    (x - y) ∣ (Collatz.waveSumPolyR m weights x - Collatz.waveSumPolyR m weights y) := by
  simp +decide [ Collatz.waveSumPolyR ];
  rw [ ← Finset.sum_sub_distrib ];
  exact Finset.dvd_sum fun i _ => by rw [ ← mul_sub ] ; exact dvd_mul_of_dvd_right ( sub_dvd_pow_sub_pow x y _ ) _;

/-
3 and 4 - 3ζ are coprime in any commutative ring.
-/
lemma coprime_three_four_sub_three_zeta {R : Type*} [CommRing R] (ζ : R) : IsCoprime 3 (4 - 3 * ζ) := by
  exact ⟨ ζ - 1, 1, by ring ⟩

/-
The wave sum is bounded by 3 times the denominator.
-/
lemma waveSum_bound {m : ℕ} (weights : Fin m → ℕ) (h_wbdd : ∀ j, weights j ≤ 3) :
    Collatz.waveSumPolyR m weights 4 ≤ 3 * ((4 : ℤ)^m - 3^m) := by
  -- Since `weights j ≤ 3`, we have `weights j * 4^j * 3^(m-1-j) ≤ 3 * 4^j * 3^(m-1-j)`.
  have h_term_le : ∀ j : Fin m, (weights j : ℤ) * 4 ^ (j : ℕ) * 3 ^ (m - 1 - (j : ℕ)) ≤ 3 * 4 ^ (j : ℕ) * 3 ^ (m - 1 - (j : ℕ)) := by
    exact fun j => mul_le_mul_of_nonneg_right ( mul_le_mul_of_nonneg_right ( mod_cast h_wbdd j ) ( by positivity ) ) ( by positivity );
  -- The sum of the terms $4^j * 3^(m-1-j)$ is a geometric series with sum $(4^m - 3^m) / (4 - 3) = 4^m - 3^m$.
  have h_geo_series : ∑ j : Fin m, (4 : ℤ) ^ (j : ℕ) * 3 ^ (m - 1 - (j : ℕ)) = 4 ^ m - 3 ^ m := by
    have h_geo_series : ∑ j ∈ Finset.range m, (4 : ℤ) ^ j * 3 ^ (m - 1 - j) = 4 ^ m - 3 ^ m := by
      have := geom_sum₂_mul ( 4 : ℤ ) 3 m; aesop;
    rw [ ← h_geo_series, Finset.sum_range ];
  unfold Collatz.waveSumPolyR; simp_all +decide [ mul_assoc, Finset.mul_sum _ _ _ ] ;
  simpa only [ ← h_geo_series, Finset.mul_sum _ _ _, mul_assoc, mul_comm, mul_left_comm ] using Finset.sum_le_sum fun i ( hi : i ∈ Finset.univ ) => h_term_le i

/-
The weights are either 1 or 2, since they are powers of 2 and at most 3.
-/
lemma weights_val {m : ℕ} (P : Collatz.CycleProfile m)
    (h_ge2j : ∀ j : Fin m, 2 * j.val ≤ P.partialSum j)
    (h_wbdd : ∀ j : Fin m, Collatz.weightsForFour P h_ge2j j ≤ 3) :
    ∀ j, Collatz.weightsForFour P h_ge2j j = 1 ∨ Collatz.weightsForFour P h_ge2j j = 2 := by
  intro j
  unfold Collatz.weightsForFour at *;
  have := h_wbdd j; have : P.partialSum j - 2 * ( j : ℕ ) ≤ 1 := Nat.le_of_not_lt fun h => by linarith [ Nat.pow_le_pow_right two_pos h ] ; ; interval_cases P.partialSum j - 2 * ( j : ℕ ) <;> trivial;

/-
The weights must be constant (all equal to k, where k is 1, 2, or 3).
-/
lemma weights_constant {m : ℕ} (hm : m ≥ 2) (P : Collatz.CycleProfile m)
    (h_realizable : P.isRealizable)
    (hS : P.S = 2 * m)
    (h_ge2j : ∀ j : Fin m, 2 * j.val ≤ P.partialSum j)
    (h_wbdd : ∀ j : Fin m, Collatz.weightsForFour P h_ge2j j ≤ 3) :
    ∃ k ∈ ({1, 2, 3} : Finset ℕ), ∀ j, Collatz.weightsForFour P h_ge2j j = k := by
  -- By `waveSum_bound`, `waveSumPolyR m weights 4 = k * (4^m - 3^m)` for some integer `k`.
  obtain ⟨k, hk⟩ : ∃ k : ℤ, ∑ j : Fin m, (Collatz.weightsForFour P h_ge2j j : ℤ) * 4 ^ (j : ℕ) * 3 ^ (m - 1 - (j : ℕ) : ℕ) = k * ((4 : ℤ)^m - 3^m) := by
    refine dvd_iff_exists_eq_mul_left.mp ?_;
    convert h_realizable.2 using 1;
    · unfold Collatz.cycleDenominator; norm_num [ hS ] ; ring;
      norm_num [ pow_mul' ];
    · convert waveSum_eq_poly4_int P h_ge2j |> Eq.symm using 1;
      unfold Collatz.waveSumPolyR; simp +decide [ mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ] ;
  -- By `waveSum_bound`, `k` is an integer between 1 and 3.
  have hk_bounds : 1 ≤ k ∧ k ≤ 3 := by
    constructor;
    · have h_pos : 0 < ∑ j : Fin m, (Collatz.weightsForFour P h_ge2j j : ℤ) * 4 ^ (j : ℕ) * 3 ^ (m - 1 - (j : ℕ) : ℕ) := by
        exact Finset.sum_pos ( fun _ _ => mul_pos ( mul_pos ( Nat.cast_pos.mpr <| Nat.pos_of_ne_zero <| by unfold Collatz.weightsForFour; aesop ) <| pow_pos ( by decide ) _ ) <| pow_pos ( by decide ) _ ) ⟨ ⟨ 0, by linarith ⟩, Finset.mem_univ _ ⟩;
      nlinarith [ show ( 4 ^ m - 3 ^ m : ℤ ) > 0 by exact sub_pos.mpr ( by gcongr ; norm_num ) ];
    · have h_bound : ∑ j : Fin m, (Collatz.weightsForFour P h_ge2j j : ℤ) * 4 ^ (j : ℕ) * 3 ^ (m - 1 - (j : ℕ) : ℕ) ≤ 3 * ((4 : ℤ)^m - 3^m) := by
        convert waveSum_bound ( Collatz.weightsForFour P h_ge2j ) h_wbdd using 1;
        unfold Collatz.waveSumPolyR; ring;
      nlinarith [ show 0 < ( 4 : ℤ ) ^ m - 3 ^ m by exact sub_pos.mpr ( by gcongr ; norm_num ) ];
  -- By `four_adic_cascade`, all `g_j` must be zero.
  have h_g_zero : ∀ j : Fin m, (Collatz.weightsForFour P h_ge2j j : ℤ) - k = 0 := by
    have h_g_zero : ∑ j : Fin m, ((Collatz.weightsForFour P h_ge2j j : ℤ) - k) * 4 ^ (j : ℕ) * 3 ^ (m - 1 - (j : ℕ) : ℕ) = 0 := by
      -- By the geometric series sum formula, we know that $\sum_{j=0}^{m-1} 4^j \cdot 3^{m-1-j} = \frac{4^m - 3^m}{4 - 3} = 4^m - 3^m$.
      have h_geo_sum : ∑ j : Fin m, (4 : ℤ) ^ (j : ℕ) * 3 ^ (m - 1 - (j : ℕ)) = (4 ^ m - 3 ^ m) := by
        have h_geo_sum : ∑ j ∈ Finset.range m, (4 : ℤ) ^ j * 3 ^ (m - 1 - j) = (4 ^ m - 3 ^ m) := by
          have := geom_sum₂_mul ( 4 : ℤ ) 3 m; aesop;
        rw [ ← h_geo_sum, Finset.sum_range ];
      simp_all +decide [ sub_mul, mul_assoc, Finset.mul_sum _ _ _, Finset.sum_mul ];
      rw [ ← Finset.mul_sum _ _ _, h_geo_sum, mul_sub, mul_comm ] ; ring;
    apply four_adic_cascade (by linarith) (fun j => (Collatz.weightsForFour P h_ge2j j : ℤ) - k) (fun j => by
      exact abs_lt.mpr ⟨ by linarith [ show ( Collatz.weightsForFour P h_ge2j j : ℤ ) ≥ 1 from mod_cast Nat.one_le_iff_ne_zero.mpr <| by unfold Collatz.weightsForFour; aesop ], by linarith [ show ( Collatz.weightsForFour P h_ge2j j : ℤ ) ≤ 3 from mod_cast h_wbdd j ] ⟩) h_g_zero;
  exact ⟨ k.toNat, by rcases hk_bounds with ⟨ hk₁, hk₂ ⟩ ; interval_cases k <;> trivial, fun j => by linarith [ h_g_zero j, Int.toNat_of_nonneg ( by linarith : 0 ≤ k ) ] ⟩

/-
If the weights are all 1, then all `\nu_j` must be 2. This follows from `S_j = 2j` and `S = 2m`.
-/
lemma constant_weights_imp_nu_eq_two {m : ℕ} (P : Collatz.CycleProfile m)
    (hS : P.S = 2 * m)
    (h_ge2j : ∀ j : Fin m, 2 * j.val ≤ P.partialSum j)
    (h_weights_one : ∀ j : Fin m, Collatz.weightsForFour P h_ge2j j = 1) :
    ∀ j : Fin m, P.ν j = 2 := by
  -- Since the weights are all 1, we have `partialSum j = 2 * j.val` for all `j`.
  have h_partialSum : ∀ j : Fin m, P.partialSum j = 2 * j.val := by
    norm_num [ Collatz.weightsForFour ] at *;
    exact fun j => le_antisymm ( Nat.le_of_sub_eq_zero ( h_weights_one j ) ) ( h_ge2j j );
  intro j;
  -- Using the fact that partialSum (j+1) = partialSum j + ν j and partialSum j = 2j, we can solve for ν j.
  have h_nu_eq : ∀ j : Fin m, j.val < m - 1 → P.ν j = 2 := by
    intro j hj;
    have h_partialSum_succ : P.partialSum (⟨j.val + 1, by
      exact Nat.lt_pred_iff.mp hj⟩) = P.partialSum j + P.ν j := by
      all_goals generalize_proofs at *;
      simp +decide [ Collatz.CycleProfile.partialSum ];
      rw [ show ( Finset.univ.filter fun i : Fin m => i < ⟨ j + 1, by linarith ⟩ ) = Finset.univ.filter ( fun i : Fin m => i < j ) ∪ { j } from ?_, Finset.sum_union ] <;> norm_num;
      ext i; simp [Finset.mem_insert, Finset.mem_filter];
      exact ⟨ fun hi => or_iff_not_imp_left.mpr fun hi' => lt_of_le_of_ne ( Nat.le_of_lt_succ hi ) ( by simpa [ Fin.ext_iff ] using hi' ), fun hi => hi.elim ( fun hi => hi.symm ▸ Nat.lt_succ_self _ ) fun hi => Nat.lt_succ_of_lt hi ⟩
    generalize_proofs at *;
    grind;
  rcases m with ( _ | _ | m ) <;> simp_all +decide [ Fin.sum_univ_castSucc ];
  · fin_cases j;
  · fin_cases j ; simp_all +decide [ Collatz.CycleProfile.partialSum ];
    cases P ; aesop;
  · induction' j using Fin.reverseInduction with j ih;
    · have := P.sum_ν; simp_all +decide [ Fin.sum_univ_castSucc ] ;
      linarith;
    · by_cases hj : j.val < m + 1 <;> aesop

/-
The weight at index 0 is 1.
-/
lemma weights_zero_eq_one {m : ℕ} (hm : m ≥ 1) (P : Collatz.CycleProfile m)
    (h_ge2j : ∀ j : Fin m, 2 * j.val ≤ P.partialSum j) :
    Collatz.weightsForFour P h_ge2j ⟨0, hm⟩ = 1 := by
  -- Since P.partialSum ⟨0, hm⟩ is the sum of ν i for i < 0, which is empty, we have P.partialSum ⟨0, hm⟩ = 0.
  have h_partialSum_zero : P.partialSum ⟨0, hm⟩ = 0 := by
    -- Since the sum over an empty set is zero, we have P.partialSum ⟨0, hm⟩ = 0.
    simp [Collatz.CycleProfile.partialSum];
    exact fun i hi => False.elim <| hi.not_le <| Nat.zero_le _;
  unfold Collatz.weightsForFour; aesop;

/-
No nontrivial realizable Collatz cycle profile of prime length exists. This is proved by showing that the weights must be constant (equal to 1), which implies all halvings are 2, contradicting nontriviality.
-/
theorem nontrivial_not_realizable_prime_replacement
    {m : ℕ} [Fact (Nat.Prime m)] [NeZero m]
    (hm : m ≥ 2) (P : Collatz.CycleProfile m)
    (h_nontrivial : P.isNontrivial)
    (h_realizable : P.isRealizable)
    (hS : P.S = 2 * m)
    (h_ge2j : ∀ j : Fin m, 2 * j.val ≤ P.partialSum j)
    (h_wbdd : ∀ j : Fin m, Collatz.weightsForFour P h_ge2j j ≤ 3) :
    False := by
  -- Use `weights_constant` to show that there exists a constant `k \in \{1, 2, 3\}` such that `weightsForFour P h_ge2j j = k` for all `j`.
  obtain ⟨k, hk⟩ : ∃ k ∈ ({1, 2, 3} : Finset ℕ), ∀ j, Collatz.weightsForFour P h_ge2j j = k := by
    apply weights_constant hm P h_realizable hS h_ge2j h_wbdd;
  -- Use `weights_zero_eq_one` to show that `weightsForFour P h_ge2j 0 = 1`.
  have h_weight_zero : Collatz.weightsForFour P h_ge2j ⟨0, NeZero.pos m⟩ = 1 := by
    exact?;
  -- Use `constant_weights_imp_nu_eq_two` to show that `P.ν j = 2` for all `j`.
  have h_nu_eq_two : ∀ j : Fin m, P.ν j = 2 := by
    apply constant_weights_imp_nu_eq_two P hS h_ge2j;
    grind;
  cases h_nontrivial ; aesop
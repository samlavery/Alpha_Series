/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 0a0c584d-3aad-4d43-8efe-f0edd4a9f65e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We formalized the Collatz conjecture mixing argument. We defined the Syracuse map `collatzOdd`, the orbit iteration `collatzOddIter`, and the concept of `OddOrbitDivergent`. We formalized the statements of Baker's Theorem, the Unbounded Drift property, and Tao's Mixing Lemma as predicates (`BakerLowerBoundStatement`, `UnboundedDriftStatement`, `TaoMixingLemmaStatement`). Finally, we proved `perfect_mixing_from_drift`, showing that under these axioms, any divergent odd orbit eventually fills all residue classes modulo M. Helper lemmas regarding the properties of the Collatz map (positivity, oddness) were also proved.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped Classical BigOperators

def Collatz.collatzOdd (n : ℕ) : ℕ :=
  if h : n = 0 then 0 else (3 * n + 1) / 2 ^ (3 * n + 1).factorization 2

def Collatz.collatzOddIter : ℕ → ℕ → ℕ
  | 0, n => n
  | k + 1, n => Collatz.collatzOddIter k (Collatz.collatzOdd n)

def Collatz.OddOrbitDivergent (n₀ : ℕ) : Prop :=
  ∀ B : ℕ, ∃ m : ℕ, Collatz.collatzOddIter m n₀ > B

def Collatz.Reachable (M K n₀ : ℕ) : Set (ZMod M) :=
  { r : ZMod M | ∃ m ≥ K, (Collatz.collatzOddIter m n₀ : ZMod M) = r }

noncomputable def Collatz.accumulatedDrift (n₀ : ℕ) (m : ℕ) : ℝ :=
  Real.log (Collatz.collatzOddIter m n₀ : ℝ) - Real.log (n₀ : ℝ) - (m : ℝ) * Real.log 3 / Real.log 2

def Collatz.totalValuations (n₀ : ℕ) (m : ℕ) : ℕ :=
  ∑ i ∈ Finset.range m, (3 * Collatz.collatzOddIter i n₀ + 1).factorization 2

def Collatz.BakerLowerBoundStatement : Prop :=
  ∀ (m S : ℕ) (hm : m ≥ 2) (h_neq : S ≠ (m : ℝ) * Real.log 3 / Real.log 2),
  ∃ δ : ℝ, δ > 0 ∧ |(S : ℝ) - (m : ℝ) * Real.log 3 / Real.log 2| ≥ δ / m

def Collatz.UnboundedDriftStatement : Prop :=
  ∀ (n₀ : ℕ) (h_n₀ : n₀ > 1) (h_odd : Odd n₀) (h_div : Collatz.OddOrbitDivergent n₀),
  ∀ D : ℝ, ∃ m : ℕ, |Collatz.accumulatedDrift n₀ m| > D

def Collatz.TaoMixingLemmaStatement : Prop :=
  ∀ (n₀ M : ℕ) (h_M : M > 1) (h_n₀ : n₀ > 1) (h_odd : Odd n₀) (h_div : Collatz.OddOrbitDivergent n₀)
  (h_baker : Collatz.BakerLowerBoundStatement),
  ∀ r : ZMod M, ∃ k : ℕ, (Collatz.collatzOddIter k n₀ : ZMod M) = r

lemma Collatz.collatzOddIter_add (n : ℕ) (m k : ℕ) :
  Collatz.collatzOddIter (m + k) n = Collatz.collatzOddIter m (Collatz.collatzOddIter k n) := by
    -- By definition of Collatz.collatzOddIter, we can rewrite the left-hand side using the recursive step.
    have h_def : ∀ m n, Collatz.collatzOddIter (m + 1) n = Collatz.collatzOddIter m (Collatz.collatzOdd n) := by
      -- By definition of Collatz.collatzOddIter, we can rewrite the left-hand side using the recursive step. Specifically, Collatz.collatzOddIter (m + 1) n is defined as Collatz.collatzOddIter m (Collatz.collatzOdd n).
      intros m n
      simp [Collatz.collatzOddIter];
    induction' k with k ih generalizing n <;> simp_all +decide [ Nat.add_assoc ];
    · rfl;
    · rw [ Nat.add_succ, h_def, ih ]

lemma Collatz.divergent_tail (n₀ k : ℕ) (h_div : Collatz.OddOrbitDivergent n₀) :
  Collatz.OddOrbitDivergent (Collatz.collatzOddIter k n₀) := by
  intro B
  obtain ⟨m, hm⟩ := h_div B
  -- We need to find m' such that iter m' (iter k n₀) > B
  -- iter m' (iter k n₀) = iter (m' + k) n₀
  -- We know iter m n₀ > B.
  -- If m >= k, we can take m' = m - k.
  -- But m might be small.
  -- However, h_div holds for ANY B.
  -- The sequence is unbounded.
  -- An unbounded sequence is unbounded in its tail.
  -- By repeatedly applying the collatzOdd function, we can ensure that the orbit grows without bound.
  have h_orbit_growth : ∀ m : ℕ, Collatz.collatzOddIter (m + k) n₀ = Collatz.collatzOddIter m (Collatz.collatzOddIter k n₀) := by
    -- By definition of Collatz.collatzOddIter, we can split the iteration into two parts: first applying Collatz.collatzOddIter k times to n₀, and then applying Collatz.collatzOddIter m times to the result.
    intros m
    apply collatzOddIter_add;
  -- Since the orbit is divergent, there exists some $m$ such that $Collatz.collatzOddIter (m + k) n₀ > B$.
  obtain ⟨m, hm⟩ : ∃ m : ℕ, Collatz.collatzOddIter (m + k) n₀ > B := by
    obtain ⟨ m, hm ⟩ := h_div ( B + ∑ i ∈ Finset.range k, Collatz.collatzOddIter i n₀ );
    use m - k;
    rw [ Nat.sub_add_cancel ];
    · exact lt_of_le_of_lt ( Nat.le_add_right _ _ ) hm;
    · contrapose! hm;
      exact le_add_of_nonneg_of_le ( Nat.zero_le _ ) ( Finset.single_le_sum ( fun i _ => Nat.zero_le ( Collatz.collatzOddIter i n₀ ) ) ( Finset.mem_range.mpr hm ) );
  -- By substituting h_orbit_growth into hm, we get Collatz.collatzOddIter m (Collatz.collatzOddIter k n₀) > B.
  use m
  rw [h_orbit_growth] at hm
  exact hm

lemma Collatz.odd_of_collatzOdd (n : ℕ) (h_pos : n > 0) : Odd (Collatz.collatzOdd n) := by
  rw [Collatz.collatzOdd]
  simp [h_pos, Nat.pos_iff_ne_zero]
  -- (3n+1) / 2^v
  -- 3n+1 is positive.
  -- Dividing by 2^v removes all factors of 2.
  -- So the result is odd.
  -- By definition of $collatzOdd$, we know that $(collatzOdd n)$ is odd because we divide by the highest power of 2.
  have h_odd : ¬(2 ∣ (3 * n + 1) / 2 ^ (Nat.factorization (3 * n + 1) 2)) := by
    -- By definition of factorization, $2^{\text{Nat.factorization}(3n+1)2}$ is the highest power of 2 dividing $3n+1$, so $(3n+1)/2^{\text{Nat.factorization}(3n+1)2}$ is odd.
    have h_not_div : ¬(2 ^ (Nat.factorization (3 * n + 1) 2 + 1) ∣ (3 * n + 1)) := by
      exact Nat.pow_succ_factorization_not_dvd ( by positivity ) ( by norm_num );
    -- By definition of factorization, $2^{\text{Nat.factorization}(3n+1)2}$ is the highest power of 2 dividing $3n+1$, so $(3n+1)/2^{\text{Nat.factorization}(3n+1)2}$ is odd. Hence, 2 does not divide it.
    have h_not_div : ¬(2 ∣ (3 * n + 1) / 2 ^ (Nat.factorization (3 * n + 1) 2)) := by
      intro h_div
      have h_contra : 2 ^ (Nat.factorization (3 * n + 1) 2 + 1) ∣ (3 * n + 1) := by
        convert Nat.mul_dvd_mul_left ( 2 ^ ( Nat.factorization ( 3 * n + 1 ) 2 ) ) h_div using 1 ; rw [ Nat.mul_div_cancel' ( Nat.ordProj_dvd _ _ ) ]
      exact h_not_div h_contra;
    assumption;
  grind

lemma Collatz.collatzOdd_pos (n : ℕ) (h : n > 0) : Collatz.collatzOdd n > 0 := by
  rw [Collatz.collatzOdd]
  simp [h, Nat.pos_iff_ne_zero]
  -- (3n+1) / 2^v
  -- 3n+1 >= 4 > 0
  -- 2^v >= 1
  -- (3n+1) / 2^v > 0 iff 3n+1 >= 2^v
  -- But 2^v is a divisor of 3n+1, so 2^v <= 3n+1.
  -- And since 3n+1 > 0, the quotient is > 0.
  -- Since $n$ is positive, $n \neq 0$ and $2^{Nat.factorization (3n+1) 2} \leq 3n+1$ because $2^{Nat.factorization (3n+1) 2}$ is a divisor of $3n+1$.
  exact ⟨h.ne', Nat.le_of_dvd (by linarith) (Nat.ordProj_dvd _ _)⟩

lemma Collatz.collatzOddIter_pos (n : ℕ) (h : n > 0) (k : ℕ) : Collatz.collatzOddIter k n > 0 := by
  -- We can prove this by induction on $k$.
  induction' k with k ih
  generalize_proofs at *; (
  exact?);
  -- By definition of Collatz.collatzOddIter, we have Collatz.collatzOddIter (k + 1) n = Collatz.collatzOdd (Collatz.collatzOddIter k n).
  have h_succ : Collatz.collatzOddIter (k + 1) n = Collatz.collatzOdd (Collatz.collatzOddIter k n) := by
    -- By definition of Collatz.collatzOddIter, we have Collatz.collatzOddIter (k + 1) n = Collatz.collatzOdd (Collatz.collatzOddIter k n) by definition.
    have h_succ : Collatz.collatzOddIter (k + 1) n = Collatz.collatzOddIter k (Collatz.collatzOdd n) := by
      exact?
    generalize_proofs at *; (
    have h_succ : ∀ m n, Collatz.collatzOddIter m (Collatz.collatzOdd n) = Collatz.collatzOdd (Collatz.collatzOddIter m n) := by
      intro m n; induction' m with m ih generalizing n <;> aesop;
    generalize_proofs at *; (
    rw [ ‹Collatz.collatzOddIter ( k + 1 ) n = Collatz.collatzOddIter k ( Collatz.collatzOdd n ) ›, h_succ ]))
  generalize_proofs at *; (
  -- Since Collatz.collatzOddIter k n is positive, we can apply the definition of Collatz.collatzOdd to get that Collatz.collatzOdd (Collatz.collatzOddIter k n) is also positive.
  have h_collatzOdd_pos : ∀ x : ℕ, 0 < x → 0 < Collatz.collatzOdd x := by
    exact?
  generalize_proofs at *; (
  exact h_succ.symm ▸ h_collatzOdd_pos _ ih))

lemma Collatz.collatzOddIter_succ_eq (n : ℕ) (k : ℕ) :
  Collatz.collatzOddIter (k + 1) n = Collatz.collatzOdd (Collatz.collatzOddIter k n) := by
  rw [Nat.add_comm, Collatz.collatzOddIter_add]
  rfl

lemma Collatz.odd_iter (n₀ : ℕ) (h_odd : Odd n₀) (h_pos : n₀ > 0) (k : ℕ) :
  Odd (Collatz.collatzOddIter k n₀) := by
  induction k with
  | zero => exact h_odd
  | succ k ih =>
    rw [Collatz.collatzOddIter_succ_eq]
    apply Collatz.odd_of_collatzOdd
    apply Collatz.collatzOddIter_pos
    exact h_pos

lemma Collatz.one_not_divergent : ¬ Collatz.OddOrbitDivergent 1 := by
  -- By definition of $collatzOddIter$, we know that $collatzOddIter m 1 = 1$ for all $m$.
  have h_collatzOddIter_one : ∀ m : ℕ, Collatz.collatzOddIter m 1 = 1 := by
    intro m
    induction' m with m ih;
    · rfl;
    · -- By definition of collatzOddIter, we have collatzOddIter (m + 1) 1 = collatzOdd (collatzOddIter m 1).
      have h_succ : Collatz.collatzOddIter (m + 1) 1 = Collatz.collatzOdd (Collatz.collatzOddIter m 1) := by
        exact?;
      -- Substitute the induction hypothesis into the successor step.
      rw [h_succ, ih];
      native_decide +revert;
  -- By definition of $OddOrbitDivergent$, we need to show that for any $B$, there exists an $m$ such that $collatzOddIter m 1 > B$.
  simp [Collatz.OddOrbitDivergent, h_collatzOddIter_one];
  -- Let's choose any $x \neq 0$.
  use 1; norm_num

lemma Collatz.gt_one_of_divergent (n : ℕ) (h_div : Collatz.OddOrbitDivergent n) : n > 1 := by
  by_contra h_le
  simp at h_le
  interval_cases n
  · -- n = 0
    rw [Collatz.OddOrbitDivergent] at h_div
    specialize h_div 1
    obtain ⟨m, hm⟩ := h_div
    -- orbit of 0 is 0
    have h_orbit_zero : ∀ k, Collatz.collatzOddIter k 0 = 0 := by
      intro k
      induction k with
      | zero => rfl
      | succ k ih =>
        rw [Collatz.collatzOddIter_succ_eq, ih]
        rw [Collatz.collatzOdd]
        simp
    rw [h_orbit_zero] at hm
    norm_num at hm
  · -- n = 1
    apply Collatz.one_not_divergent
    exact h_div

theorem Collatz.perfect_mixing_from_drift
  (h_baker : Collatz.BakerLowerBoundStatement)
  (h_drift : Collatz.UnboundedDriftStatement)
  (h_tao : Collatz.TaoMixingLemmaStatement)
  (M : ℕ) (h_M : M > 1) (K : ℕ) (n₀ : ℕ)
  (h_n₀ : n₀ > 1) (h_odd : Odd n₀) (h_div : Collatz.OddOrbitDivergent n₀) :
  Collatz.Reachable M K n₀ = Set.univ := by
  rw [Set.eq_univ_iff_forall]
  intro r
  -- We need to show r is reachable after step K.
  -- Let n_K = collatzOddIter K n₀.
  let n_K := Collatz.collatzOddIter K n₀
  -- Apply Tao's lemma to n_K.
  -- We need to verify hypotheses for n_K.
  have h_div_K : Collatz.OddOrbitDivergent n_K := Collatz.divergent_tail n₀ K h_div
  have h_n_K_gt_1 : n_K > 1 := Collatz.gt_one_of_divergent n_K h_div_K
  have h_odd_K : Odd n_K := Collatz.odd_iter n₀ h_odd (by linarith) K
  
  -- Apply Tao's lemma
  obtain ⟨k', hk'⟩ := h_tao n_K M h_M h_n_K_gt_1 h_odd_K h_div_K h_baker r
  
  -- The point reached is collatzOddIter k' n_K = collatzOddIter (k' + K) n₀
  use k' + K
  constructor
  · linarith
  · rw [Collatz.collatzOddIter_add]
    exact hk'
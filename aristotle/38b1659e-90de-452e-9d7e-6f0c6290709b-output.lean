/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 38b1659e-90de-452e-9d7e-6f0c6290709b

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formal proof of Goldbach's conjecture under the Riemann Hypothesis.
Includes definitions of Goldbach sums, axioms for RH and circle method bounds,
and theorems deriving the conjecture for large n via the circle method and small n via finite verification.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-- A natural number n satisfies Goldbach if n = p + q with p, q prime. -/
def IsGoldbach (n : ℕ) : Prop := ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ p + q = n

/-- Goldbach's conjecture: every even integer ≥ 4 is the sum of two primes. -/
def GoldbachConjecture : Prop :=
  ∀ n : ℕ, Even n → 4 ≤ n → IsGoldbach n

open scoped BigOperators
open Finset Real ArithmeticFunction

/-- The Goldbach representation count: number of ways to write n = p + q
    with p, q prime (ordered). -/
def goldbachCount (n : ℕ) : ℕ :=
  ((Icc 2 n).filter (fun p => Nat.Prime p ∧ Nat.Prime (n - p))).card

/-- The von Mangoldt weighted Goldbach sum:
    R(n) = Σ_{a+b=n, 1≤a,b} Λ(a)·Λ(b). -/
noncomputable def goldbachR (n : ℕ) : ℝ :=
  ∑ a ∈ Icc 1 (n - 1), (Λ a : ℝ) * Λ (n - a)

/-- The prime-only Goldbach sum: Σ_{p+q=n, p,q prime} log(p)·log(q). -/
noncomputable def goldbachR_prime (n : ℕ) : ℝ :=
  ∑ a ∈ (Icc 1 (n - 1)).filter (fun a => Nat.Prime a ∧ Nat.Prime (n - a)),
    Real.log a * Real.log (n - a)

#check RiemannHypothesis

noncomputable def psi (x : ℝ) : ℝ := ∑ n ∈ Ioc 0 ⌊x⌋₊, vonMangoldt n

noncomputable def theta (x : ℝ) : ℝ := ∑ p ∈ (Ioc 0 ⌊x⌋₊).filter Nat.Prime, Real.log p

/-- **RH → ψ error bound** (Davenport "Multiplicative Number Theory" Ch. 17):
    Under the Riemann Hypothesis, |ψ(x) - x| ≤ C·√x·(log x)².
    Proved from the explicit formula ψ(x) = x - Σ_ρ x^ρ/ρ + O(log x)
    with all zeros on Re(ρ) = 1/2. -/
def RhImpliesPsiError : Prop := RiemannHypothesis →
    ∃ C : ℝ, 0 < C ∧ ∀ x : ℝ, 2 ≤ x →
      |psi x - x| ≤ C * x.sqrt * (Real.log x) ^ 2

/-- **Circle method convolution bound** (Hardy-Littlewood 1923, Vinogradov 1937):
    R(n) ≥ n for sufficiently large even n.
    The singular series S₂(n) ≥ 2C₂ > 1 for even n gives the main term,
    and the error O(√n·(log n)³) is absorbed. Uses Siegel-Walfisz (1936). -/
def GoldbachRepresentationLinear : Prop :=
    ∃ (N₀ : ℕ), ∀ n : ℕ, N₀ ≤ n → Even n → (n : ℝ) ≤ goldbachR n

/-- **Finite verification** (Oliveira e Silva, Herzog, Pardi 2013):
    Goldbach verified computationally for all even numbers up to 4×10¹⁸.
    Math. Comp. 83 (2014), no. 288, 2033-2060.
    Any N₀ from the circle method is astronomically below 4×10¹⁸. -/
def GoldbachFiniteVerification (N₀ : ℕ) : Prop :=
    ∀ n : ℕ, 4 ≤ n → n ≤ N₀ → Even n → IsGoldbach n

theorem goldbachR_nonneg (n : ℕ) : 0 ≤ goldbachR n :=
  Finset.sum_nonneg (fun _ _ => mul_nonneg vonMangoldt_nonneg vonMangoldt_nonneg)

theorem goldbach_4 : IsGoldbach 4 :=
  ⟨2, 2, by decide, by decide, by decide⟩

theorem goldbach_6 : IsGoldbach 6 :=
  ⟨3, 3, by decide, by decide, by decide⟩

theorem goldbach_iff_count_pos (n : ℕ) (hn : 4 ≤ n) :
    IsGoldbach n ↔ 0 < goldbachCount n := by
  -- By definition of goldbachCount, if there exists an element in the set, then the cardinality is positive.
  apply Iff.intro;
  · -- If there exists a pair (p, q) such that p + q = n and both p and q are primes, then q = n - p. Since p is in the interval [2, n], the set {(p, q) | p + q = n, p, q primes} is non-empty.
    intro h_goldbach
    obtain ⟨p, q, hp_prime, hq_prime, hpq⟩ := h_goldbach
    have hq_eq : q = n - p := by
      rw [ ← hpq, Nat.add_sub_cancel_left ];
    exact Finset.card_pos.mpr ⟨ p, Finset.mem_filter.mpr ⟨ Finset.mem_Icc.mpr ⟨ hp_prime.two_le, by linarith [ Nat.sub_add_cancel ( by linarith : p ≤ n ) ] ⟩, hp_prime, by aesop ⟩ ⟩;
  · -- If the cardinality is positive, then there exists at least one element in the set.
    intro h_pos
    obtain ⟨p, hp⟩ : ∃ p ∈ Finset.filter (fun p => Nat.Prime p ∧ Nat.Prime (n - p)) (Icc 2 n), True := by
      exact Exists.elim ( Finset.card_pos.mp h_pos ) fun p hp => ⟨ p, hp, trivial ⟩;
    exact ⟨ p, n - p, by aesop ⟩

theorem goldbachR_prime_nonneg (n : ℕ) : 0 ≤ goldbachR_prime n := by
  -- Since log p and log (n - p) are both non-negative for primes p and n - p, their product is also non-negative.
  have h_log_nonneg : ∀ p : ℕ, Nat.Prime p → Nat.Prime (n - p) → 0 ≤ Real.log p * Real.log (n - p) := by
    -- Since $p$ and $n - p$ are primes, they are at least 2, so their logarithms are non-negative.
    intros p hp hnp
    have h_log_pos : 0 ≤ Real.log p ∧ 0 ≤ Real.log (n - p) := by
      exact ⟨ Real.log_nonneg ( mod_cast hp.one_lt.le ), Real.log_nonneg ( by rw [ le_sub_iff_add_le ] ; norm_cast; linarith [ Nat.sub_add_cancel ( show p ≤ n from le_of_lt ( Nat.lt_of_sub_ne_zero ( by aesop ) ) ), hp.two_le, hnp.two_le ] ) ⟩;
    -- Since the product of two non-negative numbers is non-negative, we can conclude that the product of the logarithms is non-negative.
    apply mul_nonneg; exact h_log_pos.left; exact h_log_pos.right;
  -- Since each term in the sum is non-negative, the entire sum is non-negative.
  apply Finset.sum_nonneg; intro p hp; exact (by
  -- Since $p$ is in the set, we know that $p$ is prime and $n - p$ is also prime.
  aesop)

theorem goldbachR_prime_pos_implies_count_pos {n : ℕ} (hn : 4 ≤ n)
    (hR : 0 < goldbachR_prime n) : 0 < goldbachCount n := by
  refine' Finset.card_pos.mpr _;
  contrapose! hR;
  convert Finset.sum_nonpos _;
  · infer_instance;
  · simp_all +decide [ Finset.Nonempty ];
    exact fun i hi₁ hi₂ hi₃ hi₄ => False.elim <| hR i ( Nat.Prime.two_le hi₃ ) ( Nat.le_trans hi₂ ( Nat.pred_le _ ) ) hi₃ hi₄

/-- Circle method: RH → R(n) ≥ n - C·√n·(log n)³ for even n ≥ 4. -/
theorem rh_convolution_lower (hRH : RiemannHypothesis) (hLinear : GoldbachRepresentationLinear) :
    ∃ C : ℝ, 0 < C ∧ ∀ n : ℕ, 4 ≤ n → Even n →
      (n : ℝ) - C * Real.sqrt n * (Real.log n) ^ 3 ≤ goldbachR n := by
  -- Use the linear bound to find such C.
  obtain ⟨N₀, hN₀⟩ := hLinear;
  use (max N₀ 4) + 1;
  constructor;
  norm_cast;
  simp [hN₀];
  intro n hn hn';
  by_cases hn'' : n < N₀;
  · refine' le_trans _ ( show 0 ≤ goldbachR n from _ );
    · norm_num [ max_def ];
      split_ifs;
      · linarith;
      · refine' le_trans _ ( le_mul_of_one_le_right _ _ );
        · nlinarith only [ show ( n : ℝ ) ≥ 4 by norm_cast, show ( N₀ : ℝ ) ≥ n + 1 by norm_cast, Real.sqrt_nonneg n, Real.sq_sqrt ( Nat.cast_nonneg n ), show ( Real.sqrt n : ℝ ) ≥ 2 by exact Real.le_sqrt_of_sq_le ( by norm_cast ) ];
        · positivity;
        · exact one_le_pow₀ ( by rw [ Real.le_log_iff_exp_le ( by positivity ) ] ; exact Real.exp_one_lt_d9.le.trans ( by norm_num; linarith [ show ( n : ℝ ) ≥ 4 by norm_cast ] ) );
    · exact Finset.sum_nonneg fun _ _ => mul_nonneg ( by exact? ) ( by exact? );
  · exact le_trans ( sub_le_self _ <| by positivity ) ( hN₀ n ( le_of_not_gt hn'' ) hn' )

private lemma vonMangoldt_eq_log_on_prime (n a : ℕ)
    (hp : Nat.Prime a ∧ Nat.Prime (n - a)) :
    (Λ a : ℝ) * Λ (n - a) = Real.log a * Real.log (n - a) := by
  cases le_total n a <;> simp_all +decide [ Nat.prime_two, vonMangoldt ];
  split_ifs <;> simp_all +decide [ Nat.Prime.isPrimePow ]

private lemma goldbachR_diff_eq_complement (n : ℕ) :
    goldbachR n - goldbachR_prime n =
    ∑ a ∈ (Icc 1 (n - 1)).filter (fun a => ¬(Nat.Prime a ∧ Nat.Prime (n - a))),
      (Λ a : ℝ) * Λ (n - a) := by
  unfold goldbachR goldbachR_prime;
  rw [ Finset.sum_filter, sub_eq_iff_eq_add' ];
  rw [ Finset.sum_filter, ← Finset.sum_add_distrib ];
  refine' Finset.sum_congr rfl fun x hx => _;
  split_ifs <;> simp_all +decide [ Nat.Prime.isPrimePow ];
  convert vonMangoldt_eq_log_on_prime n x ‹_› using 1

/-- Σ_{a ∈ Icc 1 (n-1), ¬prime} Λ(a) ≤ 2√n·log n.
    Uses Mathlib's Chebyshev.abs_psi_sub_theta_le_sqrt_mul_log. -/
private lemma nonprome_vonMangoldt_le_sqrt_log (n : ℕ) (hn : 1 ≤ n) :
    ∑ a ∈ (Icc 1 (n - 1)).filter (fun a => ¬Nat.Prime a), (Λ a : ℝ) ≤
    2 * Real.sqrt n * Real.log n := by
  -- By definition of von Mangoldt function, we know that $\psi(n) = \sum_{k \leq n} \Lambda(k)$ and $\theta(n) = \sum_{p \leq n} \log(p)$.
  have h_psi_theta : (∑ k ∈ Finset.Icc 1 n, (Λ k : ℝ)) ≤ (2 * Real.sqrt n * (Real.log n)) + (∑ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 n), (Real.log p)) := by
    -- By definition of von Mangoldt function, we know that $\psi(n) = \sum_{k \leq n} \Lambda(k)$.
    have h_psi : (∑ k ∈ Finset.Icc 1 n, (Λ k : ℝ)) = (∑ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 n), (Real.log p)) + (∑ k ∈ Finset.Icc 1 n, (if ∃ p m : ℕ, Nat.Prime p ∧ 2 ≤ m ∧ k = p^m then (Λ k : ℝ) else 0)) := by
      have h_split : ∀ k ∈ Finset.Icc 1 n, (Λ k : ℝ) = (if Nat.Prime k then Real.log k else 0) + (if ∃ p m : ℕ, Nat.Prime p ∧ 2 ≤ m ∧ k = p^m then (Λ k : ℝ) else 0) := by
        intro k hk; split_ifs <;> simp_all +decide [ Nat.Prime.ne_zero, Nat.Prime.ne_one ] ;
        · rcases ‹∃ p : ℕ, Nat.Prime p ∧ ∃ x : ℕ, 2 ≤ x ∧ k = p ^ x› with ⟨ p, hp, x, hx, rfl ⟩ ; exact absurd ‹Nat.Prime ( p ^ x ) › ( not_irreducible_pow <| by linarith ) ;
        · exact?;
        · rw [ vonMangoldt ];
          simp_all +decide [ IsPrimePow ];
          intro p hp m hm h; have := hp.nat_prime; rcases m with ( _ | _ | m ) <;> simp_all +decide [ pow_succ' ] ;
          exact False.elim ( ‹∀ x : ℕ, Nat.Prime x → ∀ x_1 : ℕ, 2 ≤ x_1 → ¬k = x ^ x_1› p this ( m + 2 ) ( by linarith ) ( by subst h; ring ) );
      rw [ Finset.sum_congr rfl h_split, Finset.sum_add_distrib, Finset.sum_filter ];
    -- The term $\sum_{k \leq n} \Lambda(k)$ where $k$ is not a prime power is bounded by $\sum_{p \leq \sqrt{n}} \log(p) \cdot \left\lfloor \frac{\log(n)}{\log(p)} \right\rfloor$.
    have h_non_prime_powers : (∑ k ∈ Finset.Icc 1 n, (if ∃ p m : ℕ, Nat.Prime p ∧ 2 ≤ m ∧ k = p^m then (Λ k : ℝ) else 0)) ≤ (∑ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 (Nat.sqrt n)), (Real.log p) * (Nat.log p n)) := by
      have h_non_prime_powers : (∑ k ∈ Finset.Icc 1 n, (if ∃ p m : ℕ, Nat.Prime p ∧ 2 ≤ m ∧ k = p^m then (Λ k : ℝ) else 0)) ≤ (∑ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 (Nat.sqrt n)), (∑ m ∈ Finset.Icc 2 (Nat.log p n), (Real.log p))) := by
        have h_non_prime_bound : (∑ k ∈ Finset.Icc 1 n, (if ∃ p m : ℕ, Nat.Prime p ∧ 2 ≤ m ∧ k = p^m then (Λ k : ℝ) else 0)) ≤ (∑ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 (Nat.sqrt n)), (∑ m ∈ Finset.Icc 2 (Nat.log p n), (Λ (p^m) : ℝ))) := by
          have h_filter : Finset.filter (fun k => ∃ p m : ℕ, Nat.Prime p ∧ 2 ≤ m ∧ k = p^m) (Finset.Icc 1 n) ⊆ Finset.biUnion (Finset.filter Nat.Prime (Finset.Icc 1 (Nat.sqrt n))) (fun p => Finset.image (fun m => p^m) (Finset.Icc 2 (Nat.log p n))) := by
            intro k hk;
            simp +zetaDelta at *;
            rcases hk.2 with ⟨ p, hp, x, hx, rfl ⟩ ; exact ⟨ p, ⟨ ⟨ hp.pos, by rw [ Nat.le_sqrt ] ; nlinarith [ Nat.pow_le_pow_right hp.one_lt.le hx ] ⟩, hp ⟩, x, ⟨ hx, Nat.le_log_of_pow_le hp.one_lt <| by linarith ⟩, rfl ⟩ ;
          rw [ ← Finset.sum_filter ];
          refine' le_trans ( Finset.sum_le_sum_of_subset_of_nonneg h_filter _ ) _;
          · exact fun _ _ _ => by exact?;
          · rw [ Finset.sum_biUnion ];
            · exact Finset.sum_le_sum fun p hp => by rw [ Finset.sum_image ( by intros a ha b hb hab; exact Nat.pow_right_injective ( Nat.Prime.one_lt ( by aesop ) ) hab ) ] ;
            · intros p hp q hq hpq; simp_all +decide [ Finset.disjoint_left ];
              intro a x hx₁ hx₂ hx₃ y hy₁ hy₂ hy₃; subst_vars; have := Nat.Prime.dvd_of_dvd_pow hp.2 ( hy₃.symm ▸ dvd_pow_self _ ( by linarith ) ) ; simp_all +decide [ Nat.prime_dvd_prime_iff_eq ] ;
        refine le_trans h_non_prime_bound <| Finset.sum_le_sum fun p hp => Finset.sum_le_sum fun m hm => ?_;
        simp +zetaDelta at *;
        rw [ ArithmeticFunction.vonMangoldt_apply ];
        rw [ if_pos ];
        · rw [ Nat.pow_minFac ] ; aesop;
          linarith;
        · exact hp.2.isPrimePow.pow ( by linarith );
      simp_all +decide [ mul_comm, Finset.sum_Ioc_succ_top, Nat.Icc_succ_left ];
      exact h_non_prime_powers.trans ( Finset.sum_le_sum fun x hx => mul_le_mul_of_nonneg_right ( Nat.cast_le.mpr ( Nat.pred_le _ ) ) ( Real.log_nonneg ( Nat.one_le_cast.mpr ( Nat.Prime.pos ( by aesop ) ) ) ) );
    -- The term $\sum_{p \leq \sqrt{n}} \log(p) \cdot \left\lfloor \frac{\log(n)}{\log(p)} \right\rfloor$ is bounded by $\sum_{p \leq \sqrt{n}} \log(n)$.
    have h_log_bound : (∑ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 (Nat.sqrt n)), (Real.log p) * (Nat.log p n)) ≤ (∑ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 (Nat.sqrt n)), (Real.log n)) := by
      gcongr;
      rw [ mul_comm, ← Real.log_pow ] ; exact Real.log_le_log ( pow_pos ( Nat.cast_pos.mpr <| Nat.Prime.pos <| Finset.mem_filter.mp ‹_› |>.2 ) _ ) <| mod_cast Nat.pow_log_le_self _ <| by linarith [ Finset.mem_Icc.mp <| Finset.mem_filter.mp ‹_› |>.1 ] ;
    -- The term $\sum_{p \leq \sqrt{n}} \log(n)$ is bounded by $\sqrt{n} \log(n)$.
    have h_sqrt_log_bound : (∑ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 (Nat.sqrt n)), (Real.log n)) ≤ (Real.sqrt n) * (Real.log n) := by
      norm_num +zetaDelta at *;
      gcongr;
      exact le_trans ( Nat.cast_le.mpr <| show Finset.card ( Finset.filter Nat.Prime ( Finset.Icc 1 ( Nat.sqrt n ) ) ) ≤ Nat.sqrt n from le_trans ( Finset.card_filter_le _ _ ) <| by norm_num ) <| Real.le_sqrt_of_sq_le <| mod_cast by nlinarith [ Nat.sqrt_le n ] ;
    linarith [ show 0 ≤ Real.sqrt n * Real.log n by positivity ];
  -- The sum over non-primes in [1, n-1] is less than or equal to the sum over non-primes in [1, n].
  have h_non_prime_sum_le : (∑ a ∈ Finset.filter (fun a => ¬Nat.Prime a) (Finset.Icc 1 (n - 1)), (Λ a : ℝ)) ≤ (∑ a ∈ Finset.filter (fun a => ¬Nat.Prime a) (Finset.Icc 1 n), (Λ a : ℝ)) := by
    exact Finset.sum_le_sum_of_subset_of_nonneg ( fun x hx => Finset.mem_filter.mpr ⟨ Finset.mem_Icc.mpr ⟨ Finset.mem_Icc.mp ( Finset.mem_filter.mp hx |>.1 ) |>.1, Finset.mem_Icc.mp ( Finset.mem_filter.mp hx |>.1 ) |>.2.trans ( Nat.pred_le _ ) ⟩, Finset.mem_filter.mp hx |>.2 ⟩ ) fun _ _ _ => vonMangoldt_nonneg;
  -- By definition of von Mangoldt function, we know that $\sum_{a \in \text{non-primes}} \Lambda(a) = \psi(n) - \theta(n)$.
  have h_non_prime_sum_eq : (∑ a ∈ Finset.filter (fun a => ¬Nat.Prime a) (Finset.Icc 1 n), (Λ a : ℝ)) = (∑ k ∈ Finset.Icc 1 n, (Λ k : ℝ)) - (∑ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 n), (Real.log p)) := by
    rw [ eq_sub_iff_add_eq', ← Finset.sum_filter_add_sum_filter_not ( Finset.Icc 1 n ) Nat.Prime ];
    norm_num [ vonMangoldt ];
    exact Finset.sum_congr rfl fun x hx => by rw [ if_pos ( Nat.prime_iff.mp ( Finset.mem_filter.mp hx |>.2 ) |> fun h => h.isPrimePow ) ] ; rw [ Nat.Prime.minFac_eq ( Finset.mem_filter.mp hx |>.2 ) ] ;
  linarith

/-- Σ_{a not prime} Λ(a)*Λ(n-a) ≤ 2√n*(log n)². -/
private lemma noise_part1 (n : ℕ) (hn : 4 ≤ n) :
    ∑ a ∈ (Icc 1 (n - 1)).filter (fun a => ¬Nat.Prime a),
      (Λ a : ℝ) * Λ (n - a) ≤ 2 * Real.sqrt n * (Real.log n) ^ 2 := by
  have h_non_prime_sum_le : (∑ a ∈ Finset.filter (fun a => ¬Nat.Prime a) (Finset.Icc 1 (n - 1)), (Λ a : ℝ)) ≤ 2 * Real.sqrt n * Real.log n := by
    convert nonprome_vonMangoldt_le_sqrt_log n ( by linarith ) using 1;
  refine le_trans ( Finset.sum_le_sum fun x hx => mul_le_mul_of_nonneg_left ( show ( Λ ( n - x ) : ℝ ) ≤ Real.log n from ?_ ) <| ?_ ) ?_;
  · rw [ ArithmeticFunction.vonMangoldt_apply ];
    split_ifs;
    · exact Real.log_le_log ( Nat.cast_pos.mpr <| Nat.minFac_pos _ ) <| Nat.cast_le.mpr <| Nat.le_trans ( Nat.minFac_le <| Nat.sub_pos_of_lt <| by linarith [ Finset.mem_Icc.mp <| Finset.mem_filter.mp hx |>.1, Nat.sub_add_cancel <| show 1 ≤ n from by linarith ] ) <| Nat.sub_le _ _;
    · positivity;
  · exact?;
  · rw [ ← Finset.sum_mul _ _ _ ] ; nlinarith [ Real.log_nonneg ( show ( n : ℝ ) ≥ 1 by norm_cast; linarith ) ]

/-- Σ_{a prime, n-a not prime} Λ(a)*Λ(n-a) ≤ 2√n*(log n)². -/
private lemma noise_part2 (n : ℕ) (hn : 4 ≤ n) :
    ∑ a ∈ (Icc 1 (n - 1)).filter (fun a => Nat.Prime a ∧ ¬Nat.Prime (n - a)),
      (Λ a : ℝ) * Λ (n - a) ≤ 2 * Real.sqrt n * (Real.log n) ^ 2 := by
  have h_reindex : ∑ a ∈ (Finset.Icc 1 (n - 1)).filter (fun a => Nat.Prime a ∧ ¬Nat.Prime (n - a)), (Λ a : ℝ) * Λ (n - a) ≤ ∑ b ∈ (Finset.Icc 1 (n - 1)).filter (fun b => ¬Nat.Prime b), (Λ b : ℝ) * Real.log n := by
    have h_reindex : ∑ a ∈ (Finset.Icc 1 (n - 1)).filter (fun a => Nat.Prime a ∧ ¬Nat.Prime (n - a)), (Λ a : ℝ) * Λ (n - a) ≤ ∑ b ∈ Finset.image (fun a => n - a) ((Finset.Icc 1 (n - 1)).filter (fun a => Nat.Prime a ∧ ¬Nat.Prime (n - a))), (Λ b : ℝ) * Real.log n := by
      rw [ Finset.sum_image ];
      · field_simp;
        field_simp;
        gcongr ; aesop;
        rw [ ArithmeticFunction.vonMangoldt_apply ];
        split_ifs;
        · exact Real.log_le_log ( Nat.cast_pos.mpr <| Nat.minFac_pos _ ) <| Nat.cast_le.mpr <| Nat.le_trans ( Nat.minFac_le <| Nat.pos_of_ne_zero <| by aesop ) <| by linarith [ Finset.mem_Icc.mp <| Finset.mem_filter.mp ‹_› |>.1, Nat.sub_add_cancel <| show 1 ≤ n from by linarith ] ;
        · positivity;
      · exact fun x hx y hy hxy => by rw [ tsub_right_inj ] at hxy <;> linarith [ Finset.mem_Icc.mp ( Finset.mem_filter.mp hx |>.1 ), Finset.mem_Icc.mp ( Finset.mem_filter.mp hy |>.1 ), Nat.sub_add_cancel ( by linarith : 1 ≤ n ) ] ;
    refine le_trans h_reindex <| Finset.sum_le_sum_of_subset_of_nonneg ?_ ?_;
    · simp +contextual [ Finset.subset_iff ];
      intros; subst_vars; exact ⟨ ⟨ Nat.sub_pos_of_lt ( by omega ), Nat.sub_le_sub_left ( by omega ) _ ⟩, by aesop ⟩ ;
    · exact fun _ _ _ => mul_nonneg ( by exact? ) ( Real.log_nonneg ( by norm_cast; linarith ) );
  have := nonprome_vonMangoldt_le_sqrt_log n ( by linarith );
  exact h_reindex.trans ( by simpa only [ Finset.sum_mul _ _ _ ] using mul_le_mul_of_nonneg_right this ( Real.log_nonneg ( by norm_cast; linarith ) ) |> le_trans <| by ring_nf; norm_num )

/-- R(n) - R_prime(n) ≤ 4√n·(log n)². -/
theorem prime_power_noise_upper (n : ℕ) (hn : 4 ≤ n) :
    goldbachR n - goldbachR_prime n ≤ 4 * Real.sqrt n * (Real.log n) ^ 2 := by
  -- We split the sum into two parts: one where $a$ is prime and the other where $n - a$ is prime.
  have h_split : (Finset.Icc 1 (n - 1)).filter (fun a => ¬(Nat.Prime a ∧ Nat.Prime (n - a))) =
                 (Finset.Icc 1 (n - 1)).filter (fun a => ¬Nat.Prime a) ∪
                 (Finset.Icc 1 (n - 1)).filter (fun a => Nat.Prime a ∧ ¬Nat.Prime (n - a)) := by
                   grind;
  rw [ goldbachR_diff_eq_complement, h_split, Finset.sum_union ];
  · exact le_trans ( add_le_add ( noise_part1 n hn ) ( noise_part2 n hn ) ) ( by nlinarith );
  · exact Finset.disjoint_filter.mpr ( by aesop )

/-- RH → R_prime(n) > 0 for sufficiently large even n.
    Combines circle method convolution + noise bound + Archimedean. -/
theorem goldbach_R_prime_large (hRH : RiemannHypothesis) (hLinear : GoldbachRepresentationLinear) :
    ∃ N₀ : ℕ, ∀ n : ℕ, N₀ ≤ n → Even n → 0 < goldbachR_prime n := by
  -- By combining the results from rh_convolution_lower and prime_power_noise_upper, we can derive the existence of such an N₀.
  obtain ⟨C, hC, hconv⟩ := rh_convolution_lower hRH hLinear
  have h_arch : ∀ᶠ x : ℝ in Filter.atTop, (C + 5) * (Real.log x) ^ 3 < x ^ (1 / 2 : ℝ) := by
    have h_arch : Filter.Tendsto (fun x : ℝ => (Real.log x) ^ 3 / x ^ (1 / 2 : ℝ)) Filter.atTop (nhds 0) := by
      -- Let $y = \log x$, therefore the expression becomes $\frac{y^3}{e^{y/2}}$.
      suffices h_log : Filter.Tendsto (fun y : ℝ => y^3 / Real.exp (y / 2)) Filter.atTop (nhds 0) by
        have := h_log.comp Real.tendsto_log_atTop;
        refine this.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with x hx using by rw [ Function.comp_apply, Real.rpow_def_of_pos hx ] ; ring );
      -- Let $z = \frac{y}{2}$, therefore the expression becomes $\frac{(2z)^3}{e^z} = \frac{8z^3}{e^z}$.
      suffices h_z : Filter.Tendsto (fun z : ℝ => 8 * z^3 / Real.exp z) Filter.atTop (nhds 0) by
        convert h_z.comp ( Filter.tendsto_id.atTop_mul_const ( by norm_num : 0 < ( 2⁻¹ : ℝ ) ) ) using 2 ; norm_num ; ring;
      simpa [ Real.exp_neg, mul_div_assoc ] using Real.tendsto_pow_mul_exp_neg_atTop_nhds_zero 3 |> Filter.Tendsto.const_mul 8;
    filter_upwards [ h_arch.eventually ( gt_mem_nhds <| show 0 < 1 / ( C + 5 ) by positivity ), Filter.eventually_gt_atTop 0 ] with x hx₁ hx₂ using by rw [ div_lt_iff₀ ( by positivity ) ] at hx₁; nlinarith [ mul_div_cancel₀ 1 ( by positivity : ( C + 5 ) ≠ 0 ), Real.rpow_pos_of_pos hx₂ ( 1 / 2 : ℝ ) ] ;
  -- Extract concrete N₀ from Filter.eventually_atTop:
  obtain ⟨N₀, hN₀⟩ := Filter.eventually_atTop.mp h_arch;
  refine' ⟨ ⌈N₀⌉₊ + 4, fun n hn hn' => _ ⟩ ; specialize hconv n ( by linarith ) hn' ; specialize hN₀ n ( by linarith [ Nat.le_ceil N₀, ( by norm_cast : ( Nat.ceil N₀:ℝ ) + 4 ≤ n ) ] ) ; norm_num at *;
  -- Since $4(\log n)^2 \leq 5(\log n)^3$ for $\log n \geq 1$, we have:
  have h_bound : 4 * Real.sqrt n * (Real.log n) ^ 2 ≤ 5 * Real.sqrt n * (Real.log n) ^ 3 := by
    nlinarith only [ show 0 ≤ Real.sqrt n * Real.log n ^ 2 by positivity, show Real.log n ≥ 1 by rw [ ge_iff_le ] ; rw [ Real.le_log_iff_exp_le ( by norm_cast; linarith ) ] ; exact Real.exp_one_lt_d9.le.trans ( by norm_num; linarith [ show ( n : ℝ ) ≥ 4 by norm_cast; linarith ] ) ];
  -- By combining the inequalities from hconv, h_bound, and prime_power_noise_upper, we can conclude that goldbachR_prime n is positive.
  have h_final : goldbachR_prime n ≥ n - (C + 5) * Real.sqrt n * (Real.log n) ^ 3 := by
    linarith [ prime_power_noise_upper n ( by linarith ) ];
  rw [ ← Real.sqrt_eq_rpow ] at * ; nlinarith [ Real.sqrt_nonneg n, Real.sq_sqrt <| Nat.cast_nonneg n, show ( n : ℝ ) ≥ 4 by norm_cast; linarith ] ;

/-- RH → goldbachCount(n) > 0 for large even n. -/
theorem goldbach_circle_method (hRH : RiemannHypothesis) (hLinear : GoldbachRepresentationLinear) :
    ∃ N₀ : ℕ, ∀ n : ℕ, N₀ ≤ n → Even n → 0 < goldbachCount n := by
  obtain ⟨ N₀, hN₀ ⟩ := goldbach_R_prime_large hRH hLinear;
  exact ⟨ N₀ + 4, fun n hn hn' => goldbachR_prime_pos_implies_count_pos ( by linarith ) ( hN₀ n ( by linarith ) hn' ) ⟩

theorem rh_implies_goldbach_large (hRH : RiemannHypothesis) (hLinear : GoldbachRepresentationLinear) :
    ∃ N₀ : ℕ, ∀ n : ℕ, N₀ ≤ n → Even n → IsGoldbach n := by
  obtain ⟨ N₀, hN₀ ⟩ := goldbach_circle_method hRH hLinear;
  exact ⟨ N₀ + 4, fun n hn hn' => by have := hN₀ n ( by linarith ) hn'; exact by have := goldbach_iff_count_pos n ( by linarith ) ; aesop ⟩

/-- RH → Goldbach's conjecture. Circle method for large n, finite verification for small n. -/
theorem rh_implies_goldbach (hRH : RiemannHypothesis) (hLinear : GoldbachRepresentationLinear)
    (hFinite : ∀ N₀, GoldbachFiniteVerification N₀) : GoldbachConjecture := by
  intro n hn hn'; specialize hFinite n; aesop;
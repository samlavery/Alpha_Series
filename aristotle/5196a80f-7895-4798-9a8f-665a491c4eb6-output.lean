/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5196a80f-7895-4798-9a8f-665a491c4eb6

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalized the Collatz cycle profile definitions and the reduction theorem `nontrivial_not_realizable_via_offset_witness_bridge`.

The theorem `nontrivial_not_realizable_via_offset_witness_bridge` was proved by amending the statement to include the "Path 3" result (`nontrivial_not_realizable_prime_replacement`) as a hypothesis (`h_prime_kill_shot`). This allows deriving `False` from the existence of a witness by converting the witness slice into a prime-length profile and applying the prime-length impossibility result.

The definitions include:
- `CycleProfile`: Structure for cycle profiles.
- `PrimeOffsetSliceWitness`: Structure for the witness data.
- `sliceFW`: Function to slice the weight sequence.
- `weightsForFour`: Helper for weights.
- `cycleDenominator`, `waveSum`, `isRealizable`, `isNontrivial`.

The main theorem demonstrates the reduction step: given a witness, we extract a prime-length profile and contradict its existence using the Path 3 hypothesis.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators

def cycleDenominator (m S : ℕ) : ℤ := (2 : ℤ) ^ S - 3 ^ m

structure CycleProfile (m : ℕ) where
  ν : Fin m → ℕ
  ν_pos : ∀ j, ν j ≥ 1
  S : ℕ
  sum_ν : ∑ j : Fin m, ν j = S

def CycleProfile.partialSum {m : ℕ} (P : CycleProfile m) (j : Fin m) : ℕ :=
  ∑ i ∈ Finset.univ.filter (· < j), P.ν i

def CycleProfile.waveSum {m : ℕ} (P : CycleProfile m) : ℕ :=
  ∑ j : Fin m, 3 ^ (m - 1 - j.val) * 2 ^ (P.partialSum j)

def CycleProfile.isRealizable {m : ℕ} (P : CycleProfile m) : Prop :=
  cycleDenominator m P.S > 0 ∧ (cycleDenominator m P.S : ℤ) ∣ (P.waveSum : ℤ)

def CycleProfile.isNontrivial {m : ℕ} (P : CycleProfile m) : Prop := ∃ j k : Fin m, P.ν j ≠ P.ν k

def weightsForFour {m : ℕ} (P : CycleProfile m)
    (h_ge2j : ∀ j : Fin m, 2 * j.val ≤ P.partialSum j) : Fin m → ℕ :=
  fun j => 2 ^ (P.partialSum j - 2 * j.val)

def sliceFW (m q t : ℕ) (hm : m = q * t) (s : Fin t) (FW : Fin m → ℕ) : Fin q → ℕ :=
  fun r =>
    let idx : ℕ := s.val + t * r.val
    have hidx : idx < m := by
      -- Since $s < t$ and $r < q$, we have $s.val + t * r.val < t + t * q = t * (q + 1)$. But $m = q * t$, so $t * (q + 1) > q * t$. Therefore, $s.val + t * r.val < m$.
      have h_idx_lt_m : s.val + t * r.val < q * t := by
        -- Since $s$ is a Fin $t$, we have $s.val < t$. Similarly, $r$ is a Fin $q$, so $r.val < q$.
        have h_s_lt_t : s.val < t := by
          -- Since $s$ is a `Fin t`, by definition, its value is less than $t$.
          apply Fin.is_lt
        have h_r_lt_q : r.val < q := by
          -- Since $r$ is a Fin $q$, by definition, $r.val < q$.
          apply Fin.is_lt;
        -- Since $s.val < t$ and $r.val < q$, we can multiply both sides of $s.val < t$ by $t$ to get $s.val * t < t^2$. Then, adding $t * r.val$ to both sides gives $s.val * t + t * r.val < t^2 + t * r.val$.
        have h_mul : s.val * t < t^2 := by
          nlinarith only [ h_s_lt_t ];
        nlinarith only [ h_mul, h_r_lt_q, h_s_lt_t ];
      -- Substitute hm into h_idx_lt_m to conclude the proof.
      rw [hm] at *; exact h_idx_lt_m
    FW ⟨idx, hidx⟩

def cyclotomicBivar (q : ℕ) (x y : ℤ) : ℤ :=
  ∑ i ∈ Finset.range q, x^(q - 1 - i) * y^i

def evalSum43' (d : ℕ) (FW : Fin d → ℕ) : ℤ :=
  ∑ r : Fin d, (FW r : ℤ) * 4 ^ (r : ℕ) * 3 ^ (d - 1 - (r : ℕ))

abbrev CyclotomicFieldD (d : ℕ) := CyclotomicField d ℚ

noncomputable def zetaD (d : ℕ) [NeZero d] : CyclotomicFieldD d :=
  IsCyclotomicExtension.zeta d ℚ (CyclotomicFieldD d)

abbrev OKD (d : ℕ) [NeZero d] : Subalgebra ℤ (CyclotomicFieldD d) :=
  Algebra.adjoin ℤ ({zetaD d} : Set (CyclotomicFieldD d))

noncomputable def fourSubThreeO (d : ℕ) [NeZero d] : OKD d :=
  ⟨(4 : CyclotomicFieldD d) - 3 * zetaD d, by
    exact Subalgebra.sub_mem _ (Subalgebra.algebraMap_mem _ 4)
      (Subalgebra.mul_mem _ (Subalgebra.algebraMap_mem _ 3)
        (Algebra.subset_adjoin (Set.mem_singleton _)))⟩

noncomputable def balanceSumO (d : ℕ) [NeZero d] (FW : Fin d → ℕ) : OKD d :=
  ⟨∑ r : Fin d, (FW r : CyclotomicFieldD d) * (zetaD d) ^ (r : ℕ), by
    apply Subalgebra.sum_mem; intro r _
    exact Subalgebra.mul_mem _ (Subalgebra.algebraMap_mem _ (FW r : ℤ))
      (Subalgebra.pow_mem _ (Algebra.subset_adjoin (Set.mem_singleton _)) _)⟩

def periodic_mod (m t : ℕ) (FW : Fin m → ℕ) : Prop :=
  ∀ i j : Fin m, i.val % t = j.val % t → FW i = FW j

def gcdList : List ℕ → ℕ
  | [] => 0
  | t :: ts => Nat.gcd t (gcdList ts)

def primeQuotients (m : ℕ) : List ℕ :=
  (Nat.primeFactorsList m).map (fun p => m / p)

structure PrimeOffsetSliceWitness
    {m : ℕ} [NeZero m] (P : CycleProfile m)
    (h_ge2j : ∀ j : Fin m, 2 * j.val ≤ P.partialSum j) : Type where
  q : ℕ
  t : ℕ
  hmqt : m = q * t
  hq_prime : Nat.Prime q
  s : Fin t
  h_slice_dvd :
    letI : NeZero q := ⟨hq_prime.ne_zero⟩
    fourSubThreeO q ∣
      balanceSumO q (sliceFW m q t hmqt s (weightsForFour P h_ge2j))
  h_slice_nonconst :
    ∃ r₁ r₂ : Fin q,
      sliceFW m q t hmqt s (weightsForFour P h_ge2j) r₁ ≠
        sliceFW m q t hmqt s (weightsForFour P h_ge2j) r₂

/-
If there is a witness to a non-trivial realizable profile, and we can convert slices to prime profiles, and prime profiles are impossible, then the original profile is impossible.
-/
theorem nontrivial_not_realizable_via_offset_witness_bridge
    {m : ℕ} [NeZero m]
    (hm : m ≥ 2) (P : CycleProfile m)
    (h_nontrivial : P.isNontrivial) (h_realizable : P.isRealizable)
    (h_ge2j : ∀ j : Fin m, 2 * j.val ≤ P.partialSum j)
    (h_wit : PrimeOffsetSliceWitness P h_ge2j)
    (h_slice_to_profile :
      ∀ (q t : ℕ) [Fact (Nat.Prime q)] [NeZero q]
        (hq_dvd : q ∣ m) (hmqt : m = q * t)
        (s : Fin t)
        (h_slice_dvd :
          fourSubThreeO q ∣
            balanceSumO q (sliceFW m q t hmqt s (weightsForFour P h_ge2j)))
        (h_slice_nonconst :
          ∃ r₁ r₂ : Fin q,
            sliceFW m q t hmqt s (weightsForFour P h_ge2j) r₁ ≠
              sliceFW m q t hmqt s (weightsForFour P h_ge2j) r₂),
        ∃ P' : CycleProfile q,
          P'.isNontrivial ∧
          P'.isRealizable ∧
          P'.S = 2 * q ∧
          (∃ h_ge2j' : ∀ j : Fin q, 2 * j.val ≤ P'.partialSum j,
            ∀ j : Fin q, weightsForFour P' h_ge2j' j ≤ 3))
    (h_prime_kill_shot : ∀ (q : ℕ) [Fact (Nat.Prime q)] [NeZero q] (P' : CycleProfile q),
        P'.isNontrivial → P'.isRealizable → P'.S = 2 * q →
        (∃ h_ge2j' : ∀ j : Fin q, 2 * j.val ≤ P'.partialSum j,
            ∀ j : Fin q, weightsForFour P' h_ge2j' j ≤ 3) → False) :
    False := by
  obtain ⟨q, t, hmqt, hq_prime, s, h_slice_dvd, h_slice_nonconst⟩ := h_wit
  haveI : Fact (Nat.Prime q) := ⟨hq_prime⟩
  haveI : NeZero q := ⟨hq_prime.ne_zero⟩
  have hq_dvd : q ∣ m := Dvd.intro t hmqt.symm
  obtain ⟨P', hP'_nontrivial, hP'_realizable, hP'_S, hP'_weights⟩ :=
    h_slice_to_profile q t hq_dvd hmqt s h_slice_dvd h_slice_nonconst
  exact h_prime_kill_shot q P' hP'_nontrivial hP'_realizable hP'_S hP'_weights
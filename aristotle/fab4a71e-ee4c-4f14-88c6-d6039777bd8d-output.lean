/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: fab4a71e-ee4c-4f14-88c6-d6039777bd8d

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We formalized the proof that no positive odd integer has a divergent orbit under the Syracuse map, conditional on the Baker-Tao axioms (specifically the supercritical ν-sum rate).

Key results proved:
1. `contraction_20step`: When x ≥ 3^20 and the 20-step ν-sum ≥ 33, the orbit contracts (x_{k+20} < x_k).
2. `checkpoint_below_stays_below`: Once a checkpoint value is below 3^20, all future checkpoints stay below 3^20.
3. `no_divergence_from_supercritical`: Given the supercritical rate (every 20-step window has ν-sum ≥ 33 eventually), the orbit is bounded.
4. `no_divergence`: The final theorem (conditional on the Tao axiom provided as an argument).

The proof relies on quantitative contraction arguments:
- The orbit iteration formula `collatzOddIter 20 x * 2^S = 3^20 * x + C` combined with `S ≥ 33` implies contraction for large `x`.
- The wavesum `C` is bounded by `(3^20 - 1) * 2^S`.
- Numerical facts `2 * 3^20 < 2^33` and `(3^20 + 1) * 2^33 > 2 * 3^40` ensure the contraction and stability below the threshold.

Note: The `tao_supercritical_rate` axiom could not be added directly to the environment due to tool restrictions on axioms, so the final theorem `no_divergence` takes the axiom as a hypothesis `h_tao`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

-- Residue-based lower bound for v₂(3n+1)
-- n ≡ 1 mod 8 → v₂ ≥ 2 (since 4 | 3n+1)
-- n ≡ 5 mod 8 → v₂ ≥ 3 (since 8 | 3n+1)
-- otherwise → v₂ ≥ 1 (since 2 | 3n+1 for odd n)
def etaResidue (n : ℕ) : ℕ :=
  if n % 8 = 1 then 2 else if n % 8 = 5 then 3 else 1

/-
User's definition of v2.
-/
open scoped Classical BigOperators

noncomputable def v2 (n : ℕ) : ℕ := multiplicity 2 n

/-
Syracuse map: apply 3n+1 then strip all factors of 2
-/
noncomputable def collatzOdd (n : ℕ) : ℕ :=
  (3 * n + 1) / 2 ^ v2 (3 * n + 1)

/-
k-fold Syracuse iteration
-/
noncomputable def collatzOddIter : ℕ → ℕ → ℕ
  | 0, n => n
  | k + 1, n => collatzOddIter k (collatzOdd n)

/-
Definition of divergent orbit.
-/
-- Divergent orbit: grows without bound
def OddOrbitDivergent (n₀ : ℕ) : Prop :=
  ∀ B : ℕ, ∃ m : ℕ, collatzOddIter m n₀ > B

/-
Per-step halving count (ν_j)
-/
-- Per-step halving count (ν_j)
noncomputable def orbitNu (x j : ℕ) : ℕ := v2 (3 * collatzOddIter j x + 1)

/-
Cumulative halvings over k steps
-/
-- Cumulative halvings over k steps
noncomputable def orbitS (x k : ℕ) : ℕ := ∑ j ∈ Finset.range k, orbitNu x j

/-
Wavesum (carry) over k steps
-/
-- Wavesum (carry) over k steps
noncomputable def orbitC (n : ℕ) : ℕ → ℕ
  | 0 => 0
  | k + 1 => 3 * orbitC n k + 2 ^ orbitS n k

/-
Residue envelope bounds v₂
-/
-- For odd n, the residue-based lower bound holds.
-- Key cases: n ≡ 1 mod 8 → 4 | 3n+1 → v₂ ≥ 2
--            n ≡ 5 mod 8 → 8 | 3n+1 → v₂ ≥ 3
--            otherwise   → 2 | 3n+1 → v₂ ≥ 1
lemma etaResidue_le_v2_of_odd (n : ℕ) (hn : Odd n) :
    etaResidue n ≤ v2 (3 * n + 1) := by
  -- By definition of $etaResidue$, we consider three cases: when $n \equiv 1 \pmod{8}$, $n \equiv 5 \pmod{8}$, or neither.
  by_cases h_case : n % 8 = 1 ∨ n % 8 = 5;
  · rcases h_case with ( h | h ) <;> unfold etaResidue <;> simp_all +decide [ Nat.even_iff ];
    · -- Since $3n + 1 \equiv 4 \pmod{8}$, we have $4 \mid 3n + 1$.
      have h_div4 : 4 ∣ (3 * n + 1) := by
        omega;
      obtain ⟨ k, hk ⟩ := h_div4;
      rw [ show v2 ( 3 * n + 1 ) = Nat.factorization ( 3 * n + 1 ) 2 from ?_ ];
      · rw [ hk, Nat.factorization_mul ] <;> norm_num;
        · exact le_add_of_le_of_nonneg ( by native_decide ) ( Nat.zero_le _ );
        · linarith [ hn.pos ];
      · unfold v2;
        rw [ Nat.multiplicity_eq_factorization ] ; norm_num;
        grind;
    · -- Since $3n + 1 \equiv 8 \pmod{16}$, we have $v2(3n + 1) \geq 3$.
      have h_mod : 8 ∣ (3 * n + 1) := by
        omega;
      obtain ⟨ k, hk ⟩ := h_mod;
      rw [ show v2 ( 3 * n + 1 ) = Nat.factorization ( 3 * n + 1 ) 2 from ?_ ];
      · rw [ hk, Nat.factorization_mul ] <;> norm_num;
        · exact le_add_of_le_of_nonneg ( by native_decide ) ( Nat.zero_le _ );
        · linarith [ hn.pos ];
      · unfold v2;
        rw [ Nat.multiplicity_eq_factorization ] ; norm_num;
        grind;
  · obtain ⟨ k, rfl ⟩ := hn;
    unfold etaResidue;
    split_ifs <;> simp_all +arith +decide;
    exact multiplicity_pos_of_dvd ( by omega )

/-
Syracuse preserves oddness (single step)
-/
lemma collatzOdd_odd (n : ℕ) (h_odd : Odd n) (h_pos : 0 < n) :
    Odd (collatzOdd n) := by
  -- By definition of $collatzOdd$, we have $collatzOdd n = (3n + 1) / 2^{v2(3n + 1)}$.
  have h_collatzOdd_def : collatzOdd n * 2 ^ (v2 (3 * n + 1)) = 3 * n + 1 := by
    -- By definition of collatzOdd, we have collatzOdd n = (3 * n + 1) / 2 ^ v2 (3 * n + 1).
    have h_collatzOdd_def : collatzOdd n = (3 * n + 1) / 2 ^ v2 (3 * n + 1) := by
      rfl;
    rw [ h_collatzOdd_def, Nat.div_mul_cancel ];
    unfold v2;
    norm_num [ Nat.factorization ];
  contrapose! h_collatzOdd_def; unfold v2 at *; simp_all +decide [ parity_simps ] ;
  -- By definition of $collatzOdd$, we have $collatzOdd n = (3n + 1) / 2^{v2(3n + 1)}$, so $collatzOdd n$ is odd.
  have h_collatzOdd_odd : collatzOdd n = (3 * n + 1) / 2 ^ (Nat.factorization (3 * n + 1) 2) := by
    unfold collatzOdd;
    rw [ Nat.factorization_def ];
    · rw [ v2 ];
      rw [ padicValNat_def ];
      positivity;
    · decide +revert;
  exact absurd h_collatzOdd_def ( by rw [ h_collatzOdd_odd ] ; exact Nat.not_even_iff.mpr <| Nat.odd_iff.mp <| Nat.odd_iff.mpr <| Nat.mod_two_ne_zero.mp fun h => absurd ( Nat.dvd_of_mod_eq_zero h ) <| Nat.not_dvd_ordCompl ( by norm_num ) <| by aesop )

/-
Syracuse step growth bound
-/
-- Each Syracuse step less than doubles: T(n) < 2n for odd n > 0.
-- Proof: v₂(3n+1) ≥ 1 (since 3n+1 is even for odd n), so
-- T(n) = (3n+1)/2^v ≤ (3n+1)/2. For n ≥ 1: (3n+1)/2 < 2n.
lemma collatzOdd_lt_two_mul (n : ℕ) (hn : Odd n) (hn_pos : 0 < n) :
    collatzOdd n < 2 * n := by
  -- By definition of collatzOdd, we have collatzOdd n = (3 * n + 1) / 2 ^ v2 (3 * n + 1).
  have h_collatzOdd_def : collatzOdd n = (3 * n + 1) / 2 ^ v2 (3 * n + 1) := by
    exact?;
  rw [ h_collatzOdd_def, Nat.div_lt_iff_lt_mul ];
  · -- Since $2^{v2(3n+1)}$ is the highest power of 2 dividing $3n+1$, we have $2^{v2(3n+1)} \geq 2$.
    have h_pow : 2 ^ v2 (3 * n + 1) ∣ 3 * n + 1 ∧ ¬2 ^ (v2 (3 * n + 1) + 1) ∣ 3 * n + 1 := by
      unfold v2;
      have h_v2_bounds : multiplicity 2 (3 * n + 1) = Nat.factorization (3 * n + 1) 2 := by
        rw [ Nat.multiplicity_eq_factorization ] ; norm_num;
        exact?;
      exact ⟨ h_v2_bounds.symm ▸ Nat.ordProj_dvd _ _, h_v2_bounds.symm ▸ Nat.pow_succ_factorization_not_dvd ( by positivity ) ( by norm_num ) ⟩;
    rcases k : v2 ( 3 * n + 1 ) with ( _ | _ | k ) <;> simp_all +decide [ pow_succ' ];
    · grind;
    · grind;
    · nlinarith [ Nat.le_of_dvd ( Nat.succ_pos _ ) h_pow.1, Nat.one_le_pow ‹_› 2 zero_lt_two ];
  · positivity

/-
Iteration composition
-/
lemma collatzOddIter_comp (m j n₀ : ℕ) :
    collatzOddIter j (collatzOddIter m n₀) = collatzOddIter (m + j) n₀ := by
  -- By definition of collatzOddIter, we can expand the expression.
  have h_def : ∀ k n, collatzOddIter k n = Nat.recOn k n (fun k n => collatzOdd n) := by
    intro k n;
    induction' k with k ih generalizing n;
    · rfl;
    · convert ih ( collatzOdd n ) using 1;
      exact Nat.recOn k rfl fun k ih => by aesop;
  induction j <;> simp_all +decide [ Nat.succ_add ];
  exact?

/-
The fundamental identity: collatzOddIter k x · 2^{orbitS x k} = 3^k · x + orbitC x k
-/
theorem orbit_iteration_formula (x : ℕ) (h_odd : Odd x) (h_pos : 0 < x) (k : ℕ) :
    collatzOddIter k x * 2 ^ orbitS x k = 3 ^ k * x + orbitC x k := by
  induction' k with k ih generalizing x;
  · -- The base case when $k = 0$ simplifies to $x * 2^0 = 1 * x + 0$, which is trivially true.
    simp [collatzOddIter, orbitS, orbitC];
  · -- By definition of collatzOddIter, we have collatzOddIter (k + 1) x = collatzOdd (collatzOddIter k x).
    have h_collatzOddIter_succ : collatzOddIter (k + 1) x = collatzOdd (collatzOddIter k x) := by
      -- By definition of collatzOddIter, we have collatzOddIter (k + 1) x = collatzOdd (collatzOddIter k x) for any k and x.
      have h_collatzOddIter_succ : ∀ k x, collatzOddIter (k + 1) x = collatzOdd (collatzOddIter k x) := by
        intros k x; exact (by
        induction' k with k ih generalizing x <;> simp_all +decide [ collatzOddIter ]);
      exact h_collatzOddIter_succ k x;
    -- By definition of collatzOdd, we have collatzOdd (collatzOddIter k x) = (3 * collatzOddIter k x + 1) / 2 ^ (orbitNu x k).
    have h_collatzOdd_def : collatzOdd (collatzOddIter k x) * 2 ^ (orbitNu x k) = 3 * collatzOddIter k x + 1 := by
      have h_collatzOdd_def : collatzOdd (collatzOddIter k x) * 2 ^ (multiplicity 2 (3 * collatzOddIter k x + 1)) = 3 * collatzOddIter k x + 1 := by
        have h_collatzOdd_def : collatzOdd (collatzOddIter k x) = (3 * collatzOddIter k x + 1) / 2 ^ (multiplicity 2 (3 * collatzOddIter k x + 1)) := by
          exact?;
        rw [ h_collatzOdd_def, Nat.div_mul_cancel ];
        exact?;
      exact?;
    -- By definition of orbitC, we have orbitC x (k + 1) = 3 * orbitC x k + 2 ^ (orbitS x k).
    have h_orbitC_def : orbitC x (k + 1) = 3 * orbitC x k + 2 ^ (orbitS x k) := by
      exact?;
    simp_all +decide [ pow_succ', mul_assoc, mul_comm, mul_left_comm, Finset.sum_range_succ ];
    convert congr_arg ( · * 2 ^ orbitS x k ) h_collatzOdd_def using 1 <;> ring;
    · simp +decide [ add_comm 1 k, mul_assoc, ← pow_add, orbitS ];
      exact Or.inl ( by rw [ Finset.sum_range_succ, add_comm ] );
    · linarith [ ih x h_odd h_pos ]

/-
Wavesum bound: 2 * C_k <= (3^k - 1) * 2^S_k
-/
lemma orbitC_le_wavesum_bound (x k : ℕ) :
    2 * orbitC x k ≤ (3 ^ k - 1) * 2 ^ orbitS x k := by
  -- We proceed by induction on $k$.
  induction' k with k ih generalizing x;
  · rfl;
  · -- By definition of $orbitC$ and $orbitS$, we can write
    have h_orbitC_succ : orbitC x (k + 1) = 3 * orbitC x k + 2 ^ orbitS x k := by
      rfl
    have h_orbitS_succ : orbitS x (k + 1) = orbitS x k + orbitNu x k := by
      exact Finset.sum_range_succ _ _;
    simp_all +decide [ pow_succ' ];
    zify at *;
    norm_num [ pow_add ] at * ; nlinarith [ ih x, pow_pos ( show 0 < 2 by decide ) ( orbitS x k ), pow_pos ( show 0 < 2 by decide ) ( orbitNu x k ), pow_pos ( show 0 < 3 by decide ) k ] ;

/-
Syracuse preserves oddness (iteration). Proof by induction on k, using collatzOdd_odd.
-/
lemma collatzOddIter_odd (n₀ : ℕ) (h_odd : Odd n₀) (h_pos : 0 < n₀) (k : ℕ) :
    Odd (collatzOddIter k n₀) := by
  induction k <;> simp_all +decide [ Nat.even_add, Nat.even_mul, collatzOddIter ];
  rename_i k hk;
  -- By definition of collatzOdd, we have collatzOddIter k (collatzOdd n₀) = collatzOdd (collatzOddIter k n₀).
  have h_collatzOddIter : collatzOddIter k (collatzOdd n₀) = collatzOdd (collatzOddIter k n₀) := by
    -- By definition of collatzOddIter, we have collatzOddIter k (collatzOdd n₀) = collatzOdd (collatzOddIter k n₀) by the recursive definition.
    have h_collatzOddIter : ∀ k n, collatzOddIter k (collatzOdd n) = collatzOdd (collatzOddIter k n) := by
      intro k n; induction' k with k ih generalizing n <;> aesop;
    exact h_collatzOddIter k n₀;
  exact h_collatzOddIter.symm ▸ collatzOdd_odd _ hk ( Nat.pos_of_ne_zero ( by aesop ) )

/-
Key numerical fact for contraction: 2 * 3^20 < 2^33.
-/
lemma numerical_fact_contraction : 2 * 3 ^ 20 < 2 ^ 33 := by
  norm_num

/-
Key numerical fact for stays-below: (3^20 + 1) * 2^33 > 2 * 3^40.
-/
lemma numerical_fact_stays_below : (3 ^ 20 + 1) * 2 ^ 33 > 2 * 3 ^ 40 := by
  norm_num

/-
Contraction on 20-step windows
-/
theorem contraction_20step (x : ℕ) (h_odd : Odd x) (h_pos : 0 < x)
    (h_nu : 33 ≤ orbitS x 20) (h_large : x ≥ 3 ^ 20) :
    collatzOddIter 20 x < x := by
  -- We want to show `collatzOddIter 20 x < x`, which is equivalent to `3^20 * x + orbitC x 20 < x * 2^orbitS x 20`.
  suffices h_suff : 3 ^ 20 * x + orbitC x 20 < x * 2 ^ orbitS x 20 by
    nlinarith [ orbit_iteration_formula x h_odd h_pos 20, pow_pos ( zero_lt_two' ℕ ) ( orbitS x 20 ) ];
  -- Using the inequality `orbitC x 20 ≤ (3^20 - 1) * 2^orbitS x 20 / 2`, we can substitute it into our goal.
  have h_subst : (3 ^ 20 - 1) * 2 ^ orbitS x 20 / 2 < x * (2 ^ orbitS x 20 - 3 ^ 20) := by
    rw [ Nat.div_lt_iff_lt_mul <| by norm_num ];
    nlinarith [ Nat.pow_le_pow_right ( show 1 ≤ 2 by norm_num ) h_nu, Nat.sub_add_cancel ( show 3 ^ 20 ≤ 2 ^ orbitS x 20 from le_trans ( by norm_num ) ( Nat.pow_le_pow_right ( show 1 ≤ 2 by norm_num ) h_nu ) ), Nat.sub_add_cancel ( show 1 ≤ 3 ^ 20 from by norm_num ) ];
  have h_subst : orbitC x 20 ≤ (3 ^ 20 - 1) * 2 ^ orbitS x 20 / 2 := by
    have := orbitC_le_wavesum_bound x 20; norm_num at *; omega;
  nlinarith [ Nat.sub_add_cancel ( show 3 ^ 20 ≤ 2 ^ orbitS x 20 from le_trans ( by decide ) ( pow_le_pow_right₀ ( by decide ) h_nu ) ) ]

/-
Below threshold stays below
-/
theorem checkpoint_below_stays_below (x : ℕ) (h_odd : Odd x) (h_pos : 0 < x)
    (h_nu : 33 ≤ orbitS x 20) (h_small : x < 3 ^ 20) :
    collatzOddIter 20 x < 3 ^ 20 := by
  -- From `orbit_iteration_formula`, we have `collatzOddIter 20 x * 2^orbitS x 20 = 3^20 * x + orbitC x 20`.
  have h_orbit_iter : collatzOddIter 20 x * 2 ^ orbitS x 20 = 3 ^ 20 * x + orbitC x 20 := by
    exact orbit_iteration_formula x h_odd h_pos 20;
  -- From `orbitC_le_wavesum_bound`, we have `orbitC x 20 <= (3^20 - 1) * 2^orbitS x 20 / 2`.
  have h_orbitC_bound : orbitC x 20 ≤ (3 ^ 20 - 1) * 2 ^ orbitS x 20 / 2 := by
    exact Nat.le_div_iff_mul_le zero_lt_two |>.2 ( by have := orbitC_le_wavesum_bound x 20; norm_num at *; linarith );
  norm_num [ Nat.mul_div_assoc ] at *;
  nlinarith [ Nat.div_mul_le_self ( 3486784400 * 2 ^ orbitS x 20 ) 2, pow_le_pow_right₀ ( show 1 ≤ 2 by decide ) h_nu ]

/-
Helper lemma: once the orbit is below 3^20 (at a checkpoint), it stays below 3^20 at all future checkpoints.
-/
lemma stays_below (n₀ M₀ : ℕ) (h_odd : Odd n₀)
    (h_super : ∀ M ≥ M₀, 33 ≤ orbitS (collatzOddIter M n₀) 20)
    (m : ℕ) (hm : m ≥ M₀) (h_start : collatzOddIter m n₀ < 3 ^ 20) :
    ∀ k, collatzOddIter (m + 20 * k) n₀ < 3 ^ 20 := by
  intro x; induction' x with k ih <;> simp_all +decide [ Nat.mul_succ, ← add_assoc ] ;
  -- Apply the checkpoint_below_stays_below lemma with the current state.
  have := checkpoint_below_stays_below (collatzOddIter (m + 20 * k) n₀) (collatzOddIter_odd n₀ h_odd (by
  exact Nat.pos_of_ne_zero ( by rintro rfl; contradiction )) (m + 20 * k)) (by
  exact Nat.pos_of_ne_zero fun h => by have := collatzOddIter_odd n₀ h_odd ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ( m + 20 * k ) ; aesop_cat;)
  generalize_proofs at *;
  exact this ( h_super _ ( by linarith ) ) ( by linarith ) |> fun h => by simpa only [ ← collatzOddIter_comp ] using h;

/-
Helper lemma: collatzOddIter is always positive for odd inputs.
-/
lemma collatzOddIter_pos (n : ℕ) (h_odd : Odd n) (k : ℕ) : 0 < collatzOddIter k n := by
  exact Nat.pos_of_ne_zero fun con => by have := collatzOddIter_odd n h_odd ( Nat.pos_of_ne_zero ( by aesop_cat ) ) k; aesop_cat;

/-
Helper lemma: the orbit eventually drops below 3^20 at a checkpoint.
-/
lemma eventually_small_checkpoint (n₀ M₀ : ℕ) (h_odd : Odd n₀)
    (h_super : ∀ M ≥ M₀, 33 ≤ orbitS (collatzOddIter M n₀) 20)
    (m : ℕ) (hm : m ≥ M₀) :
    ∃ k, collatzOddIter (m + 20 * k) n₀ < 3 ^ 20 := by
  by_contra h_contra;
  -- Then `a_k = collatzOddIter (m + 20 * k) n₀` is a strictly decreasing sequence of natural numbers.
  have h_decreasing : StrictAnti (fun k => collatzOddIter (m + 20 * k) n₀) := by
    refine' strictAnti_nat_of_succ_lt _;
    intro k;
    -- Applying the contraction_20step lemma to `a_k`, we get `a_{k+1} < a_k`.
    have h_contraction_step : collatzOddIter (m + 20 * k + 20) n₀ < collatzOddIter (m + 20 * k) n₀ := by
      have h_a_k_odd : Odd (collatzOddIter (m + 20 * k) n₀) := by
        apply collatzOddIter_odd;
        · assumption;
        · exact Nat.pos_of_ne_zero ( by aesop )
      have h_a_k_pos : 0 < collatzOddIter (m + 20 * k) n₀ := by
        exact Nat.pos_of_ne_zero ( by aesop )
      have h_a_k_ge : collatzOddIter (m + 20 * k) n₀ ≥ 3 ^ 20 := by
        exact le_of_not_gt fun h => h_contra ⟨ k, h ⟩
      convert contraction_20step ( collatzOddIter ( m + 20 * k ) n₀ ) h_a_k_odd h_a_k_pos _ h_a_k_ge using 1;
      · exact?;
      · convert h_super ( m + 20 * k ) ( by linarith ) using 1;
    simpa only [ Nat.mul_succ, ← add_assoc ] using h_contraction_step;
  exact absurd ( Set.infinite_range_of_injective h_decreasing.injective ) ( Set.not_infinite.mpr <| Set.finite_iff_bddAbove.mpr ⟨ _, Set.forall_mem_range.mpr fun k => h_decreasing.antitone k.zero_le ⟩ )

/-
Helper lemma: values within a window are bounded by exponential growth from the start.
-/
lemma collatzOddIter_bound_window (c : ℕ) (h_odd : Odd c) (h_pos : 0 < c) (j : ℕ) :
    collatzOddIter j c ≤ 2 ^ j * c := by
  induction' j with j ih generalizing c;
  · norm_num +zetaDelta at *;
    rfl;
  · -- By definition of collatzOddIter, we have collatzOddIter (j + 1) c = collatzOdd (collatzOddIter j c).
    have h_succ : collatzOddIter (j + 1) c = collatzOdd (collatzOddIter j c) := by
      -- By definition of collatzOddIter, we have collatzOddIter (j + 1) c = collatzOdd (collatzOddIter j c) by the recursive definition.
      have h_collatzOddIter_succ : collatzOddIter (j + 1) c = collatzOdd (collatzOddIter j c) := by
        have h_def : ∀ k c, collatzOddIter (k + 1) c = collatzOdd (collatzOddIter k c) := by
          intros k c; exact (by
          induction' k with k ih generalizing c <;> simp_all +decide [ collatzOddIter ])
        exact h_def j c;
      exact h_collatzOddIter_succ;
    -- By definition of collatzOdd, we have collatzOdd (collatzOddIter j c) < 2 * collatzOddIter j c.
    have h_collatzOdd : collatzOdd (collatzOddIter j c) < 2 * collatzOddIter j c := by
      apply collatzOdd_lt_two_mul;
      · exact?;
      · exact?;
    rw [ pow_succ', mul_assoc ] ; linarith [ ih c h_odd h_pos ]

/-
No divergence from supercritical rate
-/
theorem no_divergence_from_supercritical (n₀ : ℕ) (h_n₀ : n₀ > 1)
    (h_odd : Odd n₀) (h_div : OddOrbitDivergent n₀)
    (h_rate : ∃ M₀ : ℕ, ∀ M : ℕ, M₀ ≤ M →
      33 ≤ orbitS (collatzOddIter M n₀) 20) :
    False := by
  -- By `eventually_small_checkpoint`, there exists a `k` such that `collatzOddIter (M₀ + 20 * k) n₀ < 3 ^ 20`.
  obtain ⟨M₀, hM₀⟩ := h_rate
  obtain ⟨k, hk⟩ : ∃ k, collatzOddIter (M₀ + 20 * k) n₀ < 3 ^ 20 := by
    apply eventually_small_checkpoint n₀ M₀ h_odd hM₀ M₀ le_rfl;
  -- By `stays_below`, for all `j`, `collatzOddIter (M₀ + 20 * k + 20 * j) n₀ < 3 ^ 20`.
  have h_stays_below : ∀ j, collatzOddIter (M₀ + 20 * k + 20 * j) n₀ < 3 ^ 20 := by
    apply stays_below;
    exacts [ h_odd, hM₀, by linarith, hk ];
  -- By `collatzOddIter_bound_window`, for any `n ≥ M₀ + 20 * k`, `collatzOddIter n n₀` is bounded by `2^20 * 3^20`.
  have h_collatzOddIter_bound : ∀ n ≥ M₀ + 20 * k, collatzOddIter n n₀ < 2 ^ 20 * 3 ^ 20 := by
    intros n hn
    obtain ⟨ j, r, hr ⟩ : ∃ j r, n = M₀ + 20 * k + 20 * j + r ∧ r < 20 := by
      exact ⟨ ( n - ( M₀ + 20 * k ) ) / 20, ( n - ( M₀ + 20 * k ) ) % 20, by linarith [ Nat.div_add_mod ( n - ( M₀ + 20 * k ) ) 20, Nat.sub_add_cancel hn ], Nat.mod_lt _ ( by decide ) ⟩;
    -- By `collatzOddIter_bound_window`, we have `collatzOddIter (M₀ + 20 * k + 20 * j + r) n₀ ≤ 2^r * collatzOddIter (M₀ + 20 * k + 20 * j) n₀`.
    have h_collatzOddIter_bound_step : collatzOddIter (M₀ + 20 * k + 20 * j + r) n₀ ≤ 2 ^ r * collatzOddIter (M₀ + 20 * k + 20 * j) n₀ := by
      convert collatzOddIter_bound_window ( collatzOddIter ( M₀ + 20 * k + 20 * j ) n₀ ) _ _ r using 1;
      · exact?;
      · apply collatzOddIter_odd;
        · assumption;
        · grind;
      · apply collatzOddIter_pos;
        assumption;
    rw [ hr.1 ] ; exact lt_of_le_of_lt h_collatzOddIter_bound_step ( by nlinarith [ pow_le_pow_right₀ ( by decide : 1 ≤ 2 ) ( show r ≤ 19 by linarith ), h_stays_below j ] ) ;
  contrapose! h_div;
  norm_num [ OddOrbitDivergent ];
  exact ⟨ Max.max ( ∑ i ∈ Finset.range ( M₀ + 20 * k ), collatzOddIter i n₀ ) ( 2 ^ 20 * 3 ^ 20 ), fun n => if hn : n < M₀ + 20 * k then le_trans ( Finset.single_le_sum ( fun i _ => Nat.zero_le ( collatzOddIter i n₀ ) ) ( Finset.mem_range.mpr hn ) ) ( le_max_left _ _ ) else le_trans ( le_of_lt ( h_collatzOddIter_bound n ( le_of_not_gt hn ) ) ) ( le_max_right _ _ ) ⟩

/-
Final theorem: no odd integer > 1 has a divergent Syracuse orbit (conditional on Tao's axiom).
-/
theorem no_divergence (n₀ : ℕ) (h_n₀ : n₀ > 1) (h_odd : Odd n₀)
    (h_tao : ∀ (n : ℕ) (hn : n > 1) (ho : Odd n) (hd : OddOrbitDivergent n),
      ∃ M₀ : ℕ, ∀ M : ℕ, M₀ ≤ M → 33 ≤ orbitS (collatzOddIter M n) 20) :
    ¬OddOrbitDivergent n₀ := by
  intro h_div
  exact no_divergence_from_supercritical n₀ h_n₀ h_odd h_div (h_tao n₀ h_n₀ h_odd h_div)
/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e7b87d69-b15a-4a1f-8c45-c2e3757ddadc

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
I have successfully proved Target 1: `critical_line_real_valued_implies_deriv_im_zero`.

The proof relies on the Cauchy-Riemann equations. Specifically, I showed that if a function $f$ is real-valued on the critical line (i.e., $f(1/2 + it) \in \mathbb{R}$), then the derivative of $f$ along the imaginary direction, which corresponds to $i f'(s)$, must be real-valued (i.e., its imaginary part is 0). This was achieved by relating the complex derivative to the directional derivative along the line $1/2 + it$.

I also attempted to prove Target 2 (`exists_favorable_prime_cos`) and established several helper lemmas:
1. `sequence_not_avoiding_intervals`: A monotone sequence with step sizes tending to 0 cannot avoid a periodic set of intervals.
2. `prime_next_le_two_mul`: Bertrand's postulate ($p_{n+1} \le 2p_n$).
3. `log_primes_linearly_independent`: The logarithms of prime numbers are linearly independent over $\mathbb{Q}$.

However, the full proof of Target 2 requires the Prime Number Theorem (specifically $p_{n+1}/p_n \to 1$) to show that the step sizes of $t \log p_n$ tend to 0 (for fixed $t$), which was beyond the ATP's current reach without further guidance or libraries.

Given that the goal was to prove "one or more" of the axioms, the proof of Target 1 completes the task.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 40bd75e4-8f01-4686-9fa5-171652426ec1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check completedRiemannZeta
#check completedRiemannZeta₀
#check riemannZeta
#check RiemannHypothesis

#check completedRiemannZeta_eq
#check completedRiemannZeta₀_one_sub

theorem riemannZeta_conj (s : ℂ) : riemannZeta (starRingEnd ℂ s) = starRingEnd ℂ (riemannZeta s) := by
  -- By definition of the Riemann zeta function, we know that $\zeta(\overline{s}) = \overline{\zeta(s)}$ for all $s \neq 1$.
  have h_conj : ∀ s : ℂ, s ≠ 1 → riemannZeta (starRingEnd ℂ s) = starRingEnd ℂ (riemannZeta s) := by
    -- By definition of the Riemann zeta function, we know that ζ(s) = ∑_{n=1}^∞ 1/n^s for Re(s) > 1.
    have h_def : ∀ s : ℂ, 1 < s.re → riemannZeta s = ∑' n : ℕ, (1 : ℂ) / (n + 1 : ℂ) ^ s := by
      exact?;
    -- By definition of the Riemann zeta function, we know that ζ(s) = ∑_{n=1}^∞ 1/n^s for Re(s) > 1. Taking the conjugate of both sides, we get ζ(star s) = ∑_{n=1}^∞ 1/n^{star s}.
    have h_conj : ∀ s : ℂ, 1 < s.re → riemannZeta (starRingEnd ℂ s) = starRingEnd ℂ (riemannZeta s) := by
      intro s hs; rw [ h_def s hs, h_def ( starRingEnd ℂ s ) ( by simpa [ Complex.conj_re ] using hs ) ] ; simp +decide [ Complex.conj_re, Complex.conj_im, Complex.cpow_def ] ; ring;
      rw [ Complex.conj_tsum ] ; congr ; ext n ; norm_cast ; norm_num [ Complex.exp_conj, Complex.log_conj ] ; ring;
      norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im ];
    intro s hs; exact (by
    -- By the identity theorem for analytic functions, if two analytic functions agree on a set with an accumulation point, they are equal everywhere.
    have h_identity : ∀ s : ℂ, s ≠ 1 → riemannZeta (starRingEnd ℂ s) = starRingEnd ℂ (riemannZeta s) := by
      have h_analytic : AnalyticOn ℂ (fun s => riemannZeta s) (Set.univ \ {1}) := by
        apply_rules [ DifferentiableOn.analyticOn ];
        · intro s hs; exact (by
          exact DifferentiableAt.differentiableWithinAt ( by exact differentiableAt_riemannZeta hs.2 ));
        · exact isOpen_univ.sdiff isClosed_singleton
      have h_conj_analytic : AnalyticOn ℂ (fun s => starRingEnd ℂ (riemannZeta (starRingEnd ℂ s))) (Set.univ \ {1}) := by
        apply_rules [ DifferentiableOn.analyticOn ];
        · intro s hs;
          have h_conj_analytic : DifferentiableAt ℂ (fun s => riemannZeta s) (starRingEnd ℂ s) := by
            exact h_analytic.differentiableOn.differentiableAt ( IsOpen.mem_nhds ( isOpen_univ.sdiff isClosed_singleton ) ⟨ Set.mem_univ _, by simpa [ Complex.ext_iff ] using hs.2 ⟩ );
          have h_conj_analytic : HasDerivAt (fun s => starRingEnd ℂ (riemannZeta (starRingEnd ℂ s))) (starRingEnd ℂ (deriv (fun s => riemannZeta s) (starRingEnd ℂ s))) s := by
            rw [ hasDerivAt_iff_tendsto_slope_zero ];
            have := h_conj_analytic.hasDerivAt.tendsto_slope_zero;
            convert Complex.continuous_conj.continuousAt.tendsto.comp ( this.comp ( show Filter.Tendsto ( fun t : ℂ => starRingEnd ℂ t ) ( nhdsWithin 0 { 0 } ᶜ ) ( nhdsWithin 0 { 0 } ᶜ ) from ?_ ) ) using 2 <;> norm_num;
            rw [ Metric.tendsto_nhdsWithin_nhdsWithin ] ; aesop;
          exact h_conj_analytic.differentiableAt.differentiableWithinAt;
        · exact isOpen_univ.sdiff isClosed_singleton
      have h_identity : ∀ s : ℂ, s ≠ 1 → riemannZeta s = starRingEnd ℂ (riemannZeta (starRingEnd ℂ s)) := by
        intro s hs
        have h_eq : ∀ s : ℂ, 1 < s.re → riemannZeta s = starRingEnd ℂ (riemannZeta (starRingEnd ℂ s)) := by
          aesop;
        have h_identity : AnalyticOnNhd ℂ (fun s => riemannZeta s - starRingEnd ℂ (riemannZeta (starRingEnd ℂ s))) (Set.univ \ {1}) := by
          apply_rules [ AnalyticOnNhd.sub, h_analytic, h_conj_analytic ];
          · apply_rules [ DifferentiableOn.analyticOnNhd ];
            · exact h_analytic.differentiableOn;
            · exact isOpen_univ.sdiff isClosed_singleton;
          · apply_rules [ DifferentiableOn.analyticOnNhd ];
            · exact h_conj_analytic.differentiableOn;
            · exact isOpen_univ.sdiff isClosed_singleton;
        have h_identity : ∀ s : ℂ, s ≠ 1 → riemannZeta s - starRingEnd ℂ (riemannZeta (starRingEnd ℂ s)) = 0 := by
          intro s hs;
          apply h_identity.eqOn_zero_of_preconnected_of_frequently_eq_zero;
          -- The set of complex numbers excluding 1 is connected.
          have h_connected : IsConnected (Set.univ \ {1} : Set ℂ) := by
            have h_connected : IsConnected (Set.univ \ {0} : Set ℂ) := by
              have h_connected : IsConnected (Set.range (fun z : ℂ => Complex.exp z)) := by
                exact isConnected_range ( Complex.continuous_exp );
              convert h_connected using 1;
              ext; simp [Complex.exp_ne_zero];
            convert h_connected.image _ _ using 1;
            rotate_left;
            use fun s => s + 1;
            · exact continuousOn_id.add continuousOn_const;
            · ext; simp [Set.mem_image];
          exact h_connected.isPreconnected;
          exact ⟨ Set.mem_univ 2, by norm_num ⟩;
          · rw [ Metric.nhdsWithin_basis_ball.frequently_iff ];
            intro ε hε;
            refine' ⟨ 2 + ε / 2, _, _ ⟩ <;> norm_num [ hε.ne' ];
            · linarith [ abs_of_pos hε ];
            · convert sub_eq_zero.mpr ( h_eq ( 2 + ε / 2 ) ( by norm_num; linarith ) ) using 1 ; norm_num [ Complex.ext_iff ];
          · exact ⟨ Set.mem_univ _, hs ⟩;
        exact eq_of_sub_eq_zero <| h_identity s hs;
      intro s hs; specialize h_identity ( starRingEnd ℂ s ) ; simp_all +decide [ Complex.ext_iff ] ;
    exact h_identity s hs);
  by_cases hs : s = 1 <;> simp_all +decide;
  rw [ riemannZeta_one ] ; norm_num [ Complex.ext_iff ];
  norm_num [ Complex.normSq, Complex.div_re, Complex.div_im, Complex.log_re, Complex.log_im ] ; ring ; norm_num [ Real.pi_pos.le ];
  rw [ Complex.arg ] ; norm_num [ Real.pi_pos.le ]

#print Complex.Gammaℝ
#print completedRiemannZeta

theorem gammaR_conj (s : ℂ) : Complex.Gammaℝ (starRingEnd ℂ s) = starRingEnd ℂ (Complex.Gammaℝ s) := by
  unfold Complex.Gammaℝ;
  norm_num [ Complex.cpow_def_of_ne_zero, Real.pi_pos.ne' ];
  congr! 1;
  · norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im ];
    norm_num [ Complex.arg ] ; ring ; norm_num;
    norm_num [ Real.pi_pos.le ];
  · convert Complex.Gamma_conj _ using 2 ; ring;
    norm_num [ Complex.ext_iff ]

#check differentiable_completedZeta₀

theorem one_sub_eq_conj_on_critical_line (t : ℝ) :
    (1 : ℂ) - ⟨1/2, t⟩ = starRingEnd ℂ ⟨1/2, t⟩ := by
  norm_num [ Complex.ext_iff ]

theorem completedZeta_real_on_critical_line (t : ℝ) :
    (completedRiemannZeta ⟨1/2, t⟩).im = 0 := by
  -- By definition of $Zeta(s)$, we know that $Zeta(s) = \Gamma(s) \cdot \zeta(s)$.
  have hZeta_def : completedRiemannZeta ⟨1/2, t⟩ = Complex.Gammaℝ ⟨1/2, t⟩ * riemannZeta ⟨1/2, t⟩ := by
    rw [ completedRiemannZeta ];
    norm_num [ riemannZeta, HurwitzZeta.hurwitzZetaEven ];
    rw [ Function.update_of_ne ] <;> norm_num [ Complex.Gammaℝ ];
    · rw [ mul_div_cancel₀ ] ; norm_num [ Complex.Gamma_eq_zero_iff ];
      norm_num [ Complex.ext_iff ] ; intros ; linarith;
    · norm_num [ Complex.ext_iff ];
  -- Using the properties of the Gamma function and the Riemann zeta function, we can simplify the expression.
  have h_gamma_zeta : Complex.Gammaℝ ⟨1/2, t⟩ * riemannZeta ⟨1/2, t⟩ = Complex.Gammaℝ ⟨1/2, -t⟩ * riemannZeta ⟨1/2, -t⟩ := by
    have h_gamma_zeta : completedRiemannZeta ⟨1/2, t⟩ = completedRiemannZeta ⟨1/2, -t⟩ := by
      convert completedRiemannZeta_one_sub _ using 2 ; norm_num [ Complex.ext_iff ];
    rw [ ← hZeta_def, h_gamma_zeta ];
    rw [ completedRiemannZeta ];
    unfold riemannZeta; norm_num [ HurwitzZeta.hurwitzZetaEven ] ;
    rw [ Function.update_of_ne ] <;> norm_num [ Complex.Gammaℝ ];
    · rw [ mul_div_cancel₀ ] ; norm_num [ Complex.Gamma_ne_zero ];
      rw [ Complex.Gamma_eq_zero_iff ] ; norm_num [ Complex.ext_iff ];
      exact fun x hx => by linarith;
    · norm_num [ Complex.ext_iff ];
  -- Using the properties of the Gamma function and the Riemann zeta function, we can simplify the expression further.
  have h_gamma_zeta_conj : Complex.Gammaℝ ⟨1/2, -t⟩ * riemannZeta ⟨1/2, -t⟩ = starRingEnd ℂ (Complex.Gammaℝ ⟨1/2, t⟩ * riemannZeta ⟨1/2, t⟩) := by
    rw [ map_mul ];
    congr;
    · convert gammaR_conj _ using 2;
      norm_num [ Complex.ext_iff ];
    · convert riemannZeta_conj _ using 2 ; norm_num [ Complex.ext_iff ];
  norm_num [ Complex.ext_iff ] at * ; linarith

theorem xi0_functional_equation (s : ℂ) :
    completedRiemannZeta₀ (1 - s) = completedRiemannZeta₀ s := by
  exact completedRiemannZeta₀_one_sub s

theorem xi0_real_on_critical_line (t : ℝ) :
    (completedRiemannZeta₀ ⟨1/2, t⟩).im = 0 := by
  convert Complex.conj_eq_iff_im.mp _ using 1;
  -- By definition of $ξ₀$, we know that $ξ₀(s) = ξ₀(1-s)$ for all $s$.
  have h_eq : completedRiemannZeta₀ (1 - { re := 1 / 2, im := t }) = completedRiemannZeta₀ { re := 1 / 2, im := t } := by
                                                                                              exact?;
  convert Complex.conj_eq_iff_im.mpr _ using 1;
  convert completedZeta_real_on_critical_line t using 1;
  rw [ completedRiemannZeta_eq ];
  norm_num [ Complex.normSq, Complex.div_re, Complex.div_im ] ; ring

theorem xi_ne_zero_at_one : completedRiemannZeta 1 ≠ 0 := by
  norm_num [ completedRiemannZeta_eq ];
  rw [ completedRiemannZeta₀_one ];
  norm_num [ Complex.ext_iff, Complex.log_re, Complex.log_im ];
  rw [ abs_of_pos Real.pi_pos ];
  -- Since $\gamma < 1$ and $\log(4\pi) > 1$, we have $\gamma - \log(4\pi) < 0$.
  have h_gamma_lt_log : Real.eulerMascheroniConstant < 1 := by
    -- By definition of Euler-Mascheroni constant, we know that $\gamma = \lim_{n \to \infty} (H_n - \ln n)$.
    have h_gamma_def : Filter.Tendsto (fun n => (∑ k ∈ Finset.range n, (1 / (k + 1) : ℝ)) - Real.log n) Filter.atTop (nhds Real.eulerMascheroniConstant) := by
      convert Real.tendsto_harmonic_sub_log using 1;
      norm_num [ harmonic ];
    -- Since $H_n - \ln n$ is decreasing and converges to $\gamma$, we have $H_n - \ln n \geq \gamma$ for all $n$.
    have h_gamma_le : ∀ n : ℕ, n ≥ 1 → (∑ k ∈ Finset.range n, (1 / (k + 1) : ℝ)) - Real.log n ≥ Real.eulerMascheroniConstant := by
      intro n hn
      have h_decreasing : ∀ m n : ℕ, 1 ≤ m → m ≤ n → (∑ k ∈ Finset.range m, (1 / (k + 1) : ℝ)) - Real.log m ≥ (∑ k ∈ Finset.range n, (1 / (k + 1) : ℝ)) - Real.log n := by
        intros m n hm hmn
        induction' hmn with n hn ih;
        · norm_num;
        · rcases eq_or_ne n 0 <;> simp_all +decide [ Finset.sum_range_succ ];
          rw [ show ( n : ℝ ) + 1 = n * ( 1 + ( n : ℝ ) ⁻¹ ) by nlinarith only [ mul_inv_cancel₀ ( by positivity : ( n : ℝ ) ≠ 0 ) ], Real.log_mul ( by positivity ) ( by positivity ) ];
          nlinarith [ inv_mul_cancel₀ ( by positivity : ( n : ℝ ) ≠ 0 ), inv_mul_cancel₀ ( by positivity : ( n * ( 1 + ( n : ℝ ) ⁻¹ ) ) ≠ 0 ), Real.log_inv ( 1 + ( n : ℝ ) ⁻¹ ), Real.log_le_sub_one_of_pos ( inv_pos.mpr ( by positivity : 0 < ( 1 + ( n : ℝ ) ⁻¹ ) ) ), mul_inv_cancel₀ ( by positivity : ( 1 + ( n : ℝ ) ⁻¹ ) ≠ 0 ) ];
      exact le_of_tendsto h_gamma_def ( Filter.eventually_atTop.mpr ⟨ n, fun m hm => h_decreasing n m hn hm ⟩ );
    exact lt_of_le_of_lt ( h_gamma_le 4 ( by norm_num ) ) ( by norm_num; have := Real.log_two_gt_d9; norm_num1 at *; rw [ show ( 4 : ℝ ) = 2 ^ 2 by norm_num, Real.log_pow ] ; norm_num at *; linarith [ Real.log_lt_log ( by norm_num ) ( by norm_num : ( 2 : ℝ ) > 1 ) ] );
  exact fun h => absurd h <| sub_ne_zero_of_ne <| ne_of_lt <| lt_of_lt_of_le h_gamma_lt_log <| Real.le_log_iff_exp_le ( by positivity ) |>.2 <| by exact Real.exp_one_lt_d9.le.trans <| by norm_num; linarith [ Real.pi_gt_three ]

theorem gammaR_ne_zero_on_critical_line (t : ℝ) :
    Complex.Gammaℝ ⟨1/2, t⟩ ≠ 0 := by
  unfold Complex.Gammaℝ; norm_num [ Complex.Gamma_ne_zero ] ; ring;
  rw [ Complex.Gamma_eq_zero_iff ] ; norm_num [ Complex.ext_iff ];
  exact fun x hx => by linarith;

theorem critical_line_zero_iff_re_zero (t : ℝ) :
    completedRiemannZeta ⟨1/2, t⟩ = 0 ↔
      (completedRiemannZeta ⟨1/2, t⟩).re = 0 := by
  -- By definition of $Z(1/2, t)$, we know that its imaginary part is zero from `completedZeta_real_on_critical_line`.
  have h_im_zero : (completedRiemannZeta ⟨1/2, t⟩).im = 0 := by
    exact?;
  rw [ ← Complex.re_add_im ( completedRiemannZeta ⟨ 1 / 2, t ⟩ ) ] ; aesop;

theorem zeta_zero_iff_xi_zero (t : ℝ) :
    riemannZeta ⟨1/2, t⟩ = 0 ↔ completedRiemannZeta ⟨1/2, t⟩ = 0 := by
  constructor <;> intro h <;> simp_all +decide [ Complex.Gammaℝ ];
  · rw [ riemannZeta ] at h;
    rw [ HurwitzZeta.hurwitzZetaEven ] at h;
    simp_all +decide [ Function.update, Complex.Gammaℝ ];
    split_ifs at h <;> simp_all +decide [ Complex.Gamma_eq_zero_iff ];
    exact h.resolve_right fun ⟨ m, hm ⟩ => by norm_num [ Complex.ext_iff ] at hm; linarith;
  · rw [ riemannZeta_def_of_ne_zero ] <;> norm_num [ Complex.ext_iff ];
    simp_all +decide [ Complex.Gammaℝ ]

noncomputable def wobble (s : ℂ) : ℝ := (completedRiemannZeta s).im

theorem wobble_zero_on_critical_line (t : ℝ) : wobble ⟨1/2, t⟩ = 0 := by
  exact completedZeta_real_on_critical_line t

theorem wobble_decomposition (s : ℂ) (hs : s ≠ 0) (hs1 : s ≠ 1) :
    (completedRiemannZeta s).im = (completedRiemannZeta₀ s).im +
      (-(1 / (s * (1 - s)))).im := by
  rw [ completedRiemannZeta_eq ];
  rw [ show ( - ( 1 / ( s * ( 1 - s ) ) ) : ℂ ) = - ( 1 / s ) - ( 1 / ( 1 - s ) ) from ?_ ] ; ring;
  · exact?;
  · grind

theorem mul_one_sub_im (s : ℂ) :
    (s * (1 - s)).im = s.im * (1 - 2 * s.re) := by
  simpa using by ring;

theorem pole_contribution_negative_right_strip (s : ℂ)
    (hσ : 1/2 < s.re) (hσ1 : s.re < 1) (ht : 0 < s.im) :
    (-(1 / (s * (1 - s)))).im < 0 := by
  norm_num [ Complex.normSq, Complex.div_im ];
  field_simp;
  linarith

theorem zeta_zero_forces_exact_hit (s : ℂ) (hσ : 1/2 < s.re) (hσ1 : s.re < 1)
    (hzeta : riemannZeta s = 0) :
    completedRiemannZeta₀ s = 1 / (s * (1 - s)) := by
  -- Substitute hzeta into the equation and simplify.
  have h_sub : completedRiemannZeta s = 0 := by
    have h_sub : completedRiemannZeta s = riemannZeta s * Complex.Gammaℝ s := by
      rw [ completedRiemannZeta ];
      rw [ riemannZeta, HurwitzZeta.hurwitzZetaEven ];
      by_cases hs : s = 0 <;> simp_all +decide [ Complex.Gammaℝ ];
      · norm_num at hσ;
      · rw [ div_mul_cancel₀ ];
        exact mul_ne_zero ( by norm_num [ Complex.cpow_eq_zero_iff, Real.pi_ne_zero ] ) ( Complex.Gamma_ne_zero_of_re_pos ( by norm_num at *; linarith ) );
    rw [ h_sub, hzeta, MulZeroClass.zero_mul ];
  rw [ completedRiemannZeta_eq ] at h_sub;
  convert eq_add_of_sub_eq' ( eq_add_of_sub_eq' h_sub ) using 1 ; ring;
  rw [ inv_add_inv ] <;> ring <;> norm_num [ show s ≠ 0 by rintro rfl; norm_num at hσ, show 1 - s ≠ 0 by exact sub_ne_zero_of_ne <| by rintro rfl; norm_num at hσ1 ]

theorem analytic_completedZeta_in_strip :
    AnalyticOn ℂ completedRiemannZeta {s | 1/2 < s.re ∧ s.re < 1} := by
  apply_rules [ DifferentiableOn.analyticOn ];
  · refine' fun s hs => DifferentiableAt.differentiableWithinAt _;
    refine' DifferentiableAt.congr_of_eventuallyEq _ _;
    exact fun s => completedRiemannZeta₀ s - 1 / s - 1 / ( 1 - s );
    · refine' DifferentiableAt.sub ( DifferentiableAt.sub _ _ ) _;
      · exact differentiable_completedZeta₀.differentiableAt;
      · exact DifferentiableAt.div ( differentiableAt_const _ ) differentiableAt_id ( by rintro rfl; norm_num at hs );
      · exact DifferentiableAt.div ( differentiableAt_const _ ) ( differentiableAt_id.const_sub _ ) ( sub_ne_zero_of_ne <| by rintro rfl; norm_num at hs );
    · filter_upwards [ IsOpen.mem_nhds ( isOpen_Ioo.preimage Complex.continuous_re ) hs ] with t ht using completedRiemannZeta_eq t ▸ by ring;
  · exact isOpen_Ioo.preimage Complex.continuous_re

theorem xi_not_identically_zero_in_strip :
    ¬ (∀ s : ℂ, 1/2 < s.re ∧ s.re < 1 → completedRiemannZeta s = 0) := by
  by_contra h;
  -- Substitute the assumption $h$ into the goal.
  have h_sub : ∀ s : ℂ, 1 / 2 < s.re ∧ s.re < 1 → completedRiemannZeta₀ s = 1 / (s * (1 - s)) := by
    intros s hs; exact (by
    -- By definition of completedRiemannZeta, we have completedRiemannZeta s = completedRiemannZeta₀ s - 1/(s*(1-s)).
    have h_def : completedRiemannZeta s = completedRiemannZeta₀ s - 1 / (s * (1 - s)) := by
      -- By definition of completedRiemannZeta, we have completedRiemannZeta s = completedRiemannZeta₀ s - 1/(s*(1-s)) for s ≠ 0,1.
      have h_def : ∀ s : ℂ, s ≠ 0 → s ≠ 1 → completedRiemannZeta s = completedRiemannZeta₀ s - 1 / (s * (1 - s)) := by
        intros s hs hs1
        rw [completedRiemannZeta_eq];
        grind;
      exact h_def s ( by rintro rfl; norm_num at hs ) ( by rintro rfl; norm_num at hs );
    linear_combination' h s hs - h_def);
  -- Take the limit as $s \to 1$.
  have h_lim : Filter.Tendsto (fun s : ℂ => completedRiemannZeta₀ s) (nhdsWithin 1 {s : ℂ | 1 / 2 < s.re ∧ s.re < 1}) (nhds (completedRiemannZeta₀ 1)) := by
    -- The function `completedRiemannZeta₀` is entire, hence continuous everywhere.
    have h_cont : ContinuousOn completedRiemannZeta₀ Set.univ := by
      refine' Continuous.continuousOn _;
      apply_rules [ Differentiable.continuous ];
      apply_rules [ differentiable_completedZeta₀ ];
    exact h_cont.continuousAt ( by norm_num ) |> fun h => h.mono_left inf_le_left;
  -- However, we have that $\lim_{s \to 1} \frac{1}{s(1-s)} = \infty$, which contradicts the fact that $\xi_0(1)$ is finite.
  have h_contra : Filter.Tendsto (fun s : ℂ => 1 / (s * (1 - s))) (nhdsWithin 1 {s : ℂ | 1 / 2 < s.re ∧ s.re < 1}) (nhds (completedRiemannZeta₀ 1)) := by
    exact h_lim.congr' ( Filter.eventuallyEq_of_mem self_mem_nhdsWithin fun x hx => h_sub x hx ▸ rfl );
  convert absurd ( h_contra.mul ( Continuous.continuousWithinAt ( show Continuous fun s : ℂ => s * ( 1 - s ) by continuity ) ) ) _ using 1 ; norm_num;
  rw [ Metric.tendsto_nhdsWithin_nhds ] ; norm_num;
  refine' ⟨ 1 / 2, by norm_num, fun ε hε => _ ⟩;
  refine' ⟨ 1 - Min.min ε ( 1 / 2 ) / 2, _, _, _, _ ⟩ <;> norm_num [ Complex.normSq, Complex.norm_def ];
  · linarith [ show 0 < Min.min ε ( 1 / 2 ) by positivity, min_le_left ε ( 1 / 2 ), min_le_right ε ( 1 / 2 ) ];
  · linarith;
  · cases min_cases ε ( 1 / 2 ) <;> cases abs_cases ( Min.min ε ( 1 / 2 ) ) <;> linarith;
  · field_simp;
    rw [ mul_div_cancel_right₀ _ ( ne_of_gt ( Real.sqrt_pos.mpr ( by exact div_pos ( sq_pos_of_pos ( by linarith [ min_le_left ε ( 1 / 2 ), min_le_right ε ( 1 / 2 ) ] ) ) ( by norm_num ) ) ) ) ] ; norm_num

/-
If a function f is real-valued on the critical line, then Im(f'(s) * i) = 0 on that line.
-/
theorem critical_line_real_valued_implies_deriv_im_zero (f : ℂ → ℂ) (t : ℝ) :
    (∀ τ : ℝ, (f ⟨(1:ℝ)/2, τ⟩).im = 0) →
    (deriv f ⟨(1:ℝ)/2, t⟩ * Complex.I).im = 0 := by
      by_cases H : DifferentiableAt ℂ f ( ⟨ 1 / 2, t ⟩ : ℂ ) <;> simp_all +decide [ Complex.ext_iff, mul_comm ];
      · -- By definition of $f$, we know that its imaginary part is zero along the critical line.
        have h_im_zero : HasDerivAt (fun τ : ℝ => f ⟨1 / 2, τ⟩) (deriv f ⟨1 / 2, t⟩ * Complex.I) t := by
          have h_im_zero : HasDerivAt (fun τ : ℝ => f ⟨1 / 2, τ⟩) (deriv f ⟨1 / 2, t⟩ * Complex.I) t := by
            have h_g : HasDerivAt (fun τ : ℝ => ⟨1 / 2, τ⟩) (Complex.I) t := by
              simp +decide [ hasDerivAt_iff_tendsto_slope_zero, Complex.mk_eq_add_mul_I ];
              ring_nf; norm_num [ Metric.tendsto_nhdsWithin_nhds ] ; aesop;
            convert HasDerivAt.comp t ( show HasDerivAt f ( deriv f ⟨ 1 / 2, t ⟩ ) ( ⟨ 1 / 2, t ⟩ : ℂ ) from hasDerivAt_deriv_iff.mpr ?_ ) h_g using 1 ; aesop;
          exact h_im_zero;
        have h_im_zero : HasDerivAt (fun τ : ℝ => (f ⟨1 / 2, τ⟩).im) ((deriv f ⟨1 / 2, t⟩ * Complex.I).im) t := by
          rw [ hasDerivAt_iff_tendsto_slope_zero ] at *;
          convert Complex.continuous_im.continuousAt.tendsto.comp h_im_zero using 2 ; norm_num;
        have := h_im_zero.deriv; aesop;
      · rw [ deriv_zero_of_not_differentiableAt H ] ; norm_num

/-
A monotone sequence tending to infinity with step sizes tending to 0 cannot stay inside the "bad" intervals (modulo L) forever.
-/
theorem sequence_not_avoiding_intervals (u : ℕ → ℝ) (hu_mono : Monotone u) (hu_tendsto : Filter.Tendsto u Filter.atTop Filter.atTop)
    (hu_step : Filter.Tendsto (fun n ↦ u (n + 1) - u n) Filter.atTop (nhds 0))
    (L : ℝ) (hL : 0 < L) :
    ¬ (∀ n, ∃ k : ℤ, u n ∈ Set.Ioo (L/4 + k * L) (3*L/4 + k * L)) := by
      -- Since $u_{n+1} - u_n \to 0$, eventually the step size is $< L/2$.
      obtain ⟨N₀, hN₀⟩ : ∃ N₀ : ℕ, ∀ n ≥ N₀, u (n + 1) - u n < L / 2 := by
        simpa using hu_step.eventually ( gt_mem_nhds <| half_pos hL );
      -- By contradiction, assume that for all $n \geq N₀$, $u_n$ is in the bad region.
      by_contra h_contra
      have h_all_bad : ∀ n ≥ N₀, ∃ k : ℤ, u n ∈ Set.Ioo (L / 4 + k * L) (3 * L / 4 + k * L) := by
        exact fun n hn => h_contra n;
      choose! k hk using h_all_bad;
      -- Since $u_n$ is monotone and tends to infinity, the sequence $k_n$ must also tend to infinity.
      have h_k_tendsto : Filter.Tendsto (fun n => k (N₀ + n)) Filter.atTop Filter.atTop := by
        have h_k_tendsto : Filter.Tendsto (fun n => u (N₀ + n)) Filter.atTop Filter.atTop := by
          exact hu_tendsto.comp ( Filter.tendsto_atTop_mono ( fun n => by simp +arith +decide ) Filter.tendsto_id );
        rw [ Filter.tendsto_atTop_atTop ] at *;
        exact fun b => by rcases h_k_tendsto ( L / 4 + b * L ) with ⟨ i, hi ⟩ ; exact ⟨ i, fun n hin => Int.le_of_lt_add_one <| by rw [ ← @Int.cast_lt ℝ ] ; push_cast; nlinarith [ hi n hin, hk ( N₀ + n ) ( by linarith ), Set.mem_Ioo.mp ( hk ( N₀ + n ) ( by linarith ) ) ] ⟩ ;
      -- Since $k_n$ tends to infinity, there exists some $n$ such that $k_{n+1} > k_n$.
      obtain ⟨n, hn⟩ : ∃ n, k (N₀ + n + 1) > k (N₀ + n) := by
        contrapose! h_k_tendsto;
        norm_num [ Filter.tendsto_atTop_atTop ];
        exact ⟨ k ( N₀ + 0 ) + 1, fun n => ⟨ n, le_rfl, by induction' n with n ih <;> [ norm_num; linarith! [ h_k_tendsto n ] ] ⟩ ⟩;
      have := hk ( N₀ + n ) ( by linarith ) ; have := hk ( N₀ + n + 1 ) ( by linarith ) ; norm_num at * ; nlinarith [ show ( k ( N₀ + n + 1 ) : ℝ ) ≥ k ( N₀ + n ) + 1 by exact_mod_cast hn, hN₀ ( N₀ + n ) ( by linarith ), hN₀ ( N₀ + n + 1 ) ( by linarith ), hu_mono ( show N₀ + n + 1 ≥ N₀ + n from by linarith ) ] ;

/-
The (n+1)-th prime is less than or equal to twice the n-th prime.
-/
theorem prime_next_le_two_mul (n : ℕ) : Nat.nth Nat.Prime (n + 1) ≤ 2 * Nat.nth Nat.Prime n := by
  -- By Bertrand's postulate, there exists a prime $p$ such that $p_n < p \leq 2p_n$.
  obtain ⟨p, hp⟩ : ∃ p, Nat.Prime p ∧ Nat.nth Nat.Prime n < p ∧ p ≤ 2 * Nat.nth Nat.Prime n := by
    exact Nat.exists_prime_lt_and_le_two_mul _ ( by linarith [ Nat.Prime.one_lt ( Nat.prime_nth_prime n ) ] );
  rw [ Nat.nth_eq_sInf ];
  exact le_trans ( Nat.sInf_le ⟨ hp.1, fun k hk => lt_of_le_of_lt ( Nat.nth_monotone ( Nat.infinite_setOf_prime ) ( by linarith ) ) hp.2.1 ⟩ ) hp.2.2

/-
The logarithms of prime numbers are linearly independent over the rationals.
-/
theorem log_primes_linearly_independent : LinearIndependent ℚ (fun p : {p : ℕ // Nat.Prime p} => Real.log p) := by
  refine' linearIndependent_iff'.mpr _;
  intro s g hg i hi;
  -- Multiply both sides of the equation by the common denominator $D$ of all $g(p)$.
  obtain ⟨D, hD⟩ : ∃ D : ℕ, D ≠ 0 ∧ ∀ p ∈ s, ∃ k : ℤ, g p = k / D := by
    use ∏ p ∈ s, ( g p |> Rat.den );
    refine' ⟨ Finset.prod_ne_zero_iff.mpr fun p hp => Nat.cast_ne_zero.mpr ( Rat.den_nz _ ), fun p hp => _ ⟩;
    use (g p).num * (∏ p ∈ s.erase p, (g p).den);
    simp +decide [ ← Finset.mul_prod_erase _ _ hp, Rat.num_div_den ];
    rw [ mul_div_mul_right _ _ ( Finset.prod_ne_zero_iff.mpr fun q hq => Nat.cast_ne_zero.mpr <| Rat.den_nz _ ), Rat.num_div_den ];
  choose! k hk using hD.2;
  -- This implies $\log (\prod_p p^{k_p}) = 0$, so $\prod_p p^{k_p} = 1$.
  have h_prod : ∏ p ∈ s, (p.val : ℝ) ^ (k p) = 1 := by
    have h_prod : ∑ p ∈ s, k p * Real.log p = 0 := by
      simp_all +decide [ div_eq_inv_mul, mul_assoc, mul_left_comm, Finset.mul_sum _ _ _ ];
      simp_all +decide [ mul_assoc, mul_left_comm, Finset.mul_sum _ _ _, Algebra.smul_def ];
      convert congr_arg ( fun x : ℝ => x * D ) hg using 1 <;> simp +decide [ hD, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ];
    rw [ ← Real.exp_log ( Finset.prod_pos fun p hp => zpow_pos ( Nat.cast_pos.mpr p.2.pos ) _ ), Real.log_prod _ _ fun p hp => by exact zpow_ne_zero _ ( Nat.cast_ne_zero.mpr p.2.ne_zero ) ] ; aesop;
  -- Split the product into positive and negative powers: $\prod_{k_p > 0} p^{k_p} = \prod_{k_p < 0} p^{-k_p}$.
  have h_split : ∏ p ∈ s, (p.val : ℝ) ^ (k p).toNat = ∏ p ∈ s, (p.val : ℝ) ^ (-(k p)).toNat := by
    have h_split : ∏ p ∈ s, (p.val : ℝ) ^ (k p) = (∏ p ∈ s, (p.val : ℝ) ^ (k p).toNat) / (∏ p ∈ s, (p.val : ℝ) ^ (-(k p)).toNat) := by
      rw [ ← Finset.prod_div_distrib ] ; refine' Finset.prod_congr rfl fun p hp => _ ; rcases Int.eq_nat_or_neg ( k p ) with ⟨ c, hc | hc ⟩ <;> aesop;
    exact eq_of_div_eq_one <| h_split.symm.trans h_prod;
  -- By the Fundamental Theorem of Arithmetic (unique factorization), the exponents must be equal for each prime.
  have h_unique_factorization : ∀ p ∈ s, (k p).toNat = (-(k p)).toNat := by
    norm_cast at *;
    intro p hp; replace h_split := congr_arg ( fun x => x.factorization p ) h_split; simp_all +decide [ Nat.factorization_prod, Nat.Prime.ne_zero ] ;
    rw [ Finset.sum_eq_single p, Finset.sum_eq_single p ] at h_split <;> aesop;
  specialize h_unique_factorization i hi; cases' Int.eq_nat_or_neg ( k i ) ; aesop;

/-
If a monotone sequence tends to infinity with steps at most L, and there are periodic target intervals of length Gap > L, then the sequence must hit a target interval.
-/
theorem bounded_step_implies_hit (u : ℕ → ℝ) (hu_mono : Monotone u) (hu_tendsto : Filter.Tendsto u Filter.atTop Filter.atTop)
    (L : ℝ) (hL : 0 < L) (hu_step : ∀ n, u (n + 1) - u n ≤ L)
    (Gap : ℝ) (hGap : L < Gap) :
    ∃ n, ∃ k : ℤ, u n ∈ Set.Icc (k * (L + Gap)) (k * (L + Gap) + Gap) := by
      -- Let $k$ be such that $u_0 < k(L + Gap)$.
      obtain ⟨k, hk⟩ : ∃ k : ℤ, u 0 < k * (L + Gap) := by
        exact ⟨ ⌊u 0 / ( L + Gap ) ⌋₊ + 1, by push_cast; nlinarith [ Nat.lt_floor_add_one ( u 0 / ( L + Gap ) ), mul_div_cancel₀ ( u 0 ) ( by linarith : ( L + Gap ) ≠ 0 ) ] ⟩;
      -- Let $n$ be the smallest index such that $u_n \geq k(L + Gap)$.
      obtain ⟨n, hn⟩ : ∃ n : ℕ, u n ≥ k * (L + Gap) ∧ ∀ m < n, u m < k * (L + Gap) := by
        exact ⟨ Nat.find ( Filter.Eventually.exists ( hu_tendsto.eventually_ge_atTop ( k * ( L + Gap ) ) ) ), Nat.find_spec ( Filter.Eventually.exists ( hu_tendsto.eventually_ge_atTop ( k * ( L + Gap ) ) ) ), fun m mn => not_le.1 fun contra => Nat.find_min ( Filter.Eventually.exists ( hu_tendsto.eventually_ge_atTop ( k * ( L + Gap ) ) ) ) mn contra ⟩;
      rcases n <;> simp_all +decide [ sub_le_iff_le_add ];
      · linarith;
      · grind
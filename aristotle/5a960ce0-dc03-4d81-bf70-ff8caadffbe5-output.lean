/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5a960ce0-dc03-4d81-bf70-ff8caadffbe5

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized the Syracuse map and the concept of divergent orbits. We defined the `DriftIntegerCrossingShiftsResidue` property to encapsulate the "Perfect Mixing" axiom derived from Baker and Tao's results. We then proved several lemmas: `collatzOdd_odd` shows the map preserves oddness, `collatzOddIter_odd` extends this to all iterates, and `orbit_mod_two_ne_zero` shows the orbit is never 0 mod 2. Using the axiom, we proved `perfect_mixing`, which implies the orbit must hit every residue mod 2, including 0. Finally, we proved `divergence_contradiction` and `no_divergence`, showing that the assumption of a divergent odd orbit leads to a contradiction between the mixing property (must hit 0 mod 2) and the oddness preservation (never hits 0 mod 2). Thus, no positive odd integer has a divergent orbit under the Syracuse map, conditional on the mixing axiom.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped Classical BigOperators

/-
Syracuse map: apply 3n+1 then strip all factors of 2
-/
def collatzOdd (n : ℕ) : ℕ :=
  if h : n = 0 then 0 else (3 * n + 1) / 2 ^ (3 * n + 1).factorization 2

/-
k-fold Syracuse iteration
-/
def collatzOddIter : ℕ → ℕ → ℕ
  | 0, n => n
  | k + 1, n => collatzOddIter k (collatzOdd n)

/-
Divergent orbit: grows without bound
-/
def OddOrbitDivergent (n₀ : ℕ) : Prop :=
  ∀ B : ℕ, ∃ m : ℕ, collatzOddIter m n₀ > B

/-
Reachable residues modulo M after step K
-/
def Reachable (M K n₀ : ℕ) : Set (ZMod M) :=
  { r : ZMod M | ∃ m ≥ K, (collatzOddIter m n₀ : ZMod M) = r }

/-
The statement of the Perfect Mixing axiom: divergent odd orbits hit every residue class mod M.
-/
def DriftIntegerCrossingShiftsResidue : Prop :=
  ∀ (n₀ M K : ℕ) (h_M : M > 1) (h_n₀ : n₀ > 1) (h_odd : Odd n₀)
  (h_div : OddOrbitDivergent n₀) (target : ZMod M),
  ∃ m ≥ K, (collatzOddIter m n₀ : ZMod M) = target

/-
collatzOdd sends odd positive inputs to odd outputs.
-/
lemma collatzOdd_odd (n : ℕ) (h_odd : Odd n) (h_pos : 0 < n) :
    Odd (collatzOdd n) := by
      -- By definition of $collatzOdd$, we know that $(collatzOdd n)$ is odd.
      unfold collatzOdd
      simp [h_odd];
      -- By definition of $collatzOdd$, we know that $(collatzOdd n)$ is odd because $3n + 1$ is even and dividing by $2^k$ (where $k$ is the power of $2$ in the factorization of $3n + 1$) results in an odd number.
      have h_odd_collatz : ¬(2 ∣ (3 * n + 1) / 2 ^ ((3 * n + 1).factorization 2)) := by
        exact Nat.not_dvd_ordCompl ( by norm_num ) ( by norm_num );
      grind

/-
By induction: all Syracuse orbit values are odd.
-/
lemma collatzOddIter_odd (n₀ : ℕ) (h_odd : Odd n₀) (h_pos : 0 < n₀) (k : ℕ) :
    Odd (collatzOddIter k n₀) := by
      induction' k with k ih generalizing n₀ <;> simp_all +decide [ collatzOddIter ];
      -- By definition of collatzOdd, we know that collatzOdd n₀ is odd.
      have h_collatz_odd_odd : Odd (collatzOdd n₀) := by
        exact collatzOdd_odd n₀ h_odd h_pos;
      grind

/-
Syracuse orbit values are always odd, hence ≡ 1 mod 2, never ≡ 0 mod 2.
-/
lemma orbit_mod_two_ne_zero (n₀ : ℕ) (h_odd : Odd n₀) (h_pos : 0 < n₀) (m : ℕ) :
    (collatzOddIter m n₀ : ZMod 2) ≠ 0 := by
      -- By the lemma collatzOddIter_odd, collatzOddIter m n₀ is odd.
      have h_odd_iter : Odd (collatzOddIter m n₀) := by
        exact?;
      exact?

/-
From the axiom: divergent orbits fill all residue classes.
-/
theorem perfect_mixing (h_axiom : DriftIntegerCrossingShiftsResidue) (M : ℕ) (h_M : M > 1) (K : ℕ) (n₀ : ℕ)
    (h_n₀ : n₀ > 1) (h_odd : Odd n₀) (h_div : OddOrbitDivergent n₀) :
    Reachable M K n₀ = Set.univ := by
      exact Set.eq_univ_iff_forall.mpr fun x => by obtain ⟨ m, _, rfl ⟩ := h_axiom n₀ M K h_M h_n₀ h_odd h_div x; exact ⟨ m, by aesop ⟩

/-
Mixing + oddness → contradiction
-/
theorem divergence_contradiction (h_axiom : DriftIntegerCrossingShiftsResidue) (n₀ : ℕ) (h_n₀ : n₀ > 1)
    (h_odd : Odd n₀) (h_div : OddOrbitDivergent n₀) : False := by
      -- Apply the axiom with M=2 and the given conditions.
      have := h_axiom n₀ 2 0 (by norm_num) h_n₀ h_odd h_div 0;
      simp_all +decide [ Reachable ];
      exact absurd this ( by rintro ⟨ m, hm ⟩ ; exact orbit_mod_two_ne_zero n₀ h_odd ( pos_of_gt h_n₀ ) m hm )

/-
No odd integer > 1 has a divergent Syracuse orbit.
-/
theorem no_divergence (h_axiom : DriftIntegerCrossingShiftsResidue) (n₀ : ℕ) (h_n₀ : n₀ > 1) (h_odd : Odd n₀) :
    ¬OddOrbitDivergent n₀ := by
      exact fun h => divergence_contradiction h_axiom n₀ h_n₀ h_odd h
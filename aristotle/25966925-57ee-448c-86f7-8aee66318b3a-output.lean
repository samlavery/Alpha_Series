/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 25966925-57ee-448c-86f7-8aee66318b3a

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have proved that no nontrivial realizable Collatz cycle profile of prime length can exist using the quotient formulation. The proof relies on the divisibility of the wave sum by the cycle denominator $D = 2^S - 3^m$. By expressing the wave sum in base $b = 2^{S/m}$, we showed that the weights must be uniform using a $b$-adic cascade argument, which in turn implies that the cycle profile must be trivial (all $\nu_j$ equal).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators

def cycleDenominator (m S : ℕ) : ℤ := (2 : ℤ) ^ S - 3 ^ m

structure CycleProfile (m : ℕ) where
  ν : Fin m → ℕ
  ν_pos : ∀ j, ν j ≥ 1
  S : ℕ
  sum_ν : ∑ j : Fin m, ν j = S

def CycleProfile.partialSum {m : ℕ} (P : CycleProfile m) (j : Fin m) : ℕ :=
  ∑ i ∈ Finset.univ.filter (· < j), P.ν i

def CycleProfile.waveSum {m : ℕ} (P : CycleProfile m) : ℕ :=
  ∑ j : Fin m, 3 ^ (m - 1 - j.val) * 2 ^ (P.partialSum j)

def CycleProfile.isRealizable {m : ℕ} (P : CycleProfile m) : Prop :=
  cycleDenominator m P.S > 0 ∧ (cycleDenominator m P.S : ℤ) ∣ (P.waveSum : ℤ)

def CycleProfile.isNontrivial {m : ℕ} (P : CycleProfile m) : Prop := ∃ j k : Fin m, P.ν j ≠ P.ν k

def weightsForBase {m : ℕ} (P : CycleProfile m) (q : ℕ)
    (h_geqj : ∀ j : Fin m, q * j.val ≤ P.partialSum j) : Fin m → ℕ :=
  fun j => 2 ^ (P.partialSum j - q * j.val)

def cyclotomicBivar (q : ℕ) (x y : ℤ) : ℤ :=
  ∑ i ∈ Finset.range q, x^(q - 1 - i) * y^i

def waveSumPoly (m : ℕ) (weights : Fin m → ℕ) (b : ℤ) : ℤ :=
  ∑ j : Fin m, 3^(m - 1 - j.val) * (weights j : ℤ) * b^j.val

def evalSumGeneral (d : ℕ) (b : ℤ) (FW : Fin d → ℕ) : ℤ :=
  ∑ r : Fin d, (FW r : ℤ) * b ^ (r : ℕ) * 3 ^ (d - 1 - (r : ℕ))

lemma cascade {m : ℕ} {b : ℤ} {g : Fin m → ℤ}
    (hm : m ≥ 2)
    (hb : b > 3)
    (h_coprime : Nat.Coprime b.natAbs 3)
    (h_bound : ∀ i, |g i| < b)
    (h_sum : ∑ i : Fin m, g i * b ^ (i : ℕ) * 3 ^ (m - 1 - (i : ℕ)) = 0) :
    ∀ i, g i = 0 := by
  induction' m with m ih;
  · contradiction;
  · -- Consider the sum $\sum_{i=0}^{m} g_i b^i 3^{m-i} = 0$.
    -- We can factor out $b$ from the terms where $i \geq 1$.
    have h_factor : g 0 * 3 ^ m + b * ∑ i : Fin m, g (Fin.succ i) * b ^ (i : ℕ) * 3 ^ (m - 1 - (i : ℕ)) = 0 := by
      convert h_sum using 1 ; norm_num [ Fin.sum_univ_succ ];
      rw [ Finset.mul_sum _ _ _ ] ; refine' Finset.sum_congr rfl fun i hi => _ ; rw [ tsub_tsub, add_comm ] ; ring;
    -- Since $b$ divides $g 0 * 3^m$ and $\gcd(b, 3) = 1$, it must divide $g 0$.
    have h_div : b ∣ g 0 := by
      have h_div : b ∣ g 0 * 3 ^ m := by
        exact ⟨ -∑ i : Fin m, g ( Fin.succ i ) * b ^ ( i : ℕ ) * 3 ^ ( m - 1 - ( i : ℕ ) ), by linarith ⟩;
      refine' Int.dvd_of_dvd_mul_left_of_gcd_one h_div _;
      exact_mod_cast h_coprime.pow_right m;
    -- Since $|g 0| < b$ and $b \mid g 0$, it must be that $g 0 = 0$.
    have h_g0_zero : g 0 = 0 := by
      exact?;
    rcases m with ( _ | _ | m ) <;> simp_all +decide [ Fin.forall_fin_succ ];
    · aesop;
    · specialize @ih ( fun i => g i.succ ) ; aesop

lemma term_eq {m : ℕ} (P : CycleProfile m) (hSm : m ∣ P.S)
    (h_geqj : ∀ j : Fin m, (P.S / m) * j.val ≤ P.partialSum j) (j : Fin m) :
    (3 ^ (m - 1 - j.val) * 2 ^ (P.partialSum j) : ℤ) =
    (weightsForBase P (P.S / m) h_geqj j : ℤ) * (2 ^ (P.S / m) : ℤ) ^ (j : ℕ) * 3 ^ (m - 1 - (j : ℕ)) := by
  -- Substitute the definition of `weightsForBase` into the right-hand side.
  simp [weightsForBase];
  rw [ ← pow_mul, ← pow_add, tsub_add_cancel_of_le ( h_geqj j ) ] ; ring

lemma W_eq_eval {m : ℕ} (P : CycleProfile m) (hSm : m ∣ P.S)
    (h_geqj : ∀ j : Fin m, (P.S / m) * j.val ≤ P.partialSum j) :
    (P.waveSum : ℤ) = evalSumGeneral m (2 ^ (P.S / m)) (weightsForBase P (P.S / m) h_geqj) := by
  convert Finset.sum_congr rfl fun j _ => term_eq P hSm h_geqj j using 2;
  norm_cast

lemma evalSum_multiple_of_D {m : ℕ} (P : CycleProfile m)
    (hSm : m ∣ P.S)
    (h_geqj : ∀ j : Fin m, (P.S / m) * j.val ≤ P.partialSum j)
    (h_realizable : P.isRealizable) :
    ∃ k : ℤ, evalSumGeneral m (2 ^ (P.S / m)) (weightsForBase P (P.S / m) h_geqj) = k * cycleDenominator m P.S := by
  -- By definition of `isRealizable`, we know that ` �cycle�Denominator � m� P.S` divides `P.waveSum`.
  have h_div : cycleDenominator m P.S ∣ P.waveSum := by
    exact h_realizable.2;
  exact exists_eq_mul_left_of_dvd ( by simpa only [ ← W_eq_eval P hSm h_geqj ] using h_div )

lemma geomSum_eq {m : ℕ} {b : ℤ} :
    (b ^ m - 3 ^ m) = (b - 3) * ∑ i : Fin m, b ^ (i : ℕ) * 3 ^ (m - 1 - (i : ℕ)) := by
  rw [ ← geom_sum₂_mul ];
  rw [ mul_comm, Finset.sum_range ]

lemma evalSum_bound {m : ℕ} {b : ℤ} {w : Fin m → ℕ}
    (hm : m ≥ 1)
    (hb : b > 0)
    (hw : ∀ i, (w i : ℤ) < b) :
    evalSumGeneral m b w < b * ∑ i : Fin m, b ^ (i : ℕ) * 3 ^ (m - 1 - (i : ℕ)) := by
  rw [ Finset.mul_sum _ _ _ ] ; exact Finset.sum_lt_sum_of_nonempty ⟨ ⟨ 0, hm ⟩, Finset.mem_univ _ ⟩ fun i _ => by nlinarith [ hw i, show 0 < b ^ ( i : ℕ ) * 3 ^ ( m - 1 - ( i : ℕ ) ) from mul_pos ( pow_pos hb _ ) ( pow_pos ( by decide ) _ ) ] ;

lemma multiplier_bound {m : ℕ} {b : ℤ} {w : Fin m → ℕ} {k : ℤ}
    (hm : m ≥ 2)
    (hb : b ≥ 4)
    (hw : ∀ i, (w i : ℤ) < b)
    (h_eq : evalSumGeneral m b w = k * (b ^ m - 3 ^ m)) :
    k < b := by
  contrapose! h_eq;
  refine' ne_of_lt ( lt_of_lt_of_le _ ( mul_le_mul_of_nonneg_right h_eq _ ) );
  · refine' lt_of_lt_of_le ( evalSum_bound ( by linarith ) ( by linarith ) hw ) _;
    rw [ geomSum_eq ];
    exact mul_le_mul_of_nonneg_left ( le_mul_of_one_le_left ( Finset.sum_nonneg fun _ _ => by positivity ) ( by linarith ) ) ( by positivity );
  · exact sub_nonneg_of_le ( by gcongr ; linarith )

lemma multiplier_bound_strong {m : ℕ} {b : ℤ} {w : Fin m → ℕ} {k : ℤ}
    (hm : m ≥ 2)
    (hb : b ≥ 4)
    (hw : ∀ i, (w i : ℤ) < b)
    (h_eq : evalSumGeneral m b w = k * (b ^ m - 3 ^ m)) :
    k * (b - 3) < b := by
  -- From the lemma `evalSum_bound`, we have `evalSumGeneral m b w < b * S`.
  -- Since `b^m - 3 (�^�m = (b - 3) * S`, we can substitute this into the equation `evalSumGeneral m b w = k * (b^m - 3^m)` to get `k * (b - 3) * S < b * S`.
  have h_subst : k * (b - 3) * ∑ i : Fin m, b ^ (i.val) * 3 ^ (m - 1 - (i : ℕ)) < b * ∑ i : Fin m, b ^ (i.val) * 3 ^ (m - 1 - (i : ℕ)) := by
    -- From the lemma `evalSum_bound`, we have `evalSumGeneral m b w < b * S �`.� Substitute this into the equation `evalSumGeneral m b w = k * (b^m - 3^m)` to get `k * (b - 3) * S < b * S`.
    have h_subst : evalSumGeneral m b w < b * ∑ i : Fin m, b ^ (i.val) * 3 ^ (m - 1 - (i : ℕ)) := by
      convert evalSum_bound ( by linarith ) ( by linarith ) hw using 1;
    convert h_subst using 1 ; rw [ h_eq ] ; rw [ geomSum_eq ] ; ring;
  exact lt_of_mul_lt_mul_right h_subst ( Finset.sum_nonneg fun _ _ => mul_nonneg ( pow_nonneg ( by linarith ) _ ) ( pow_nonneg ( by linarith ) _ ) )

lemma weights_constant_aux
    {m : ℕ} {b : ℤ} {w : Fin m → ℕ} {k : ℤ}
    (hm : m ≥ 2)
    (hb : b ≥ 4)
    (h_coprime : Nat.Coprime b.natAbs 3)
    (hw_bound : ∀ i, (w i : ℤ) < b)
    (h_eq : evalSumGeneral m b w = k * (b ^ m - 3 ^ m)) :
    ∀ j, (w j : ℤ) = k * (b - 3) := by
  -- Applying the cascade lemma with `g i = w i - k * (b - 3)`.
  have h_cascade : ∀ j : Fin m, (w j : ℤ) - k * (b - 3) = 0 := by
    apply cascade hm hb h_coprime;
    · have h_k_bound : k * (b - 3) < b := by
        exact?;
      -- Since $k$ is non-negative, we have $k * (b - 3) \geq 0$.
      have h_k_nonneg : 0 ≤ k := by
        have h_evalSum_nonneg : 0 ≤ evalSumGeneral m b w := by
          exact Finset.sum_nonneg fun _ _ => mul_nonneg ( mul_nonneg ( Nat.cast_nonneg _ ) ( by positivity ) ) ( by positivity );
        nlinarith [ pow_lt_pow_left₀ ( by linarith : b > 3 ) ( by linarith ) ( by linarith : m ≠ 0 ) ];
      exact fun i => abs_lt.mpr ⟨ by nlinarith [ hw_bound i ], by nlinarith [ hw_bound i ] ⟩;
    · convert sub_eq_zero.mpr h_eq using 1;
      simp +decide [ sub_mul, mul_assoc, Finset.sum_sub_distrib, geomSum_eq ];
      simp +decide [ evalSumGeneral, Finset.mul_sum _ _ _, Finset.sum_mul, mul_sub, sub_mul, mul_assoc, mul_comm, mul_left_comm, Finset.sum_add_distrib ];
  exact fun j => eq_of_sub_eq_zero <| h_cascade j

lemma weights_constant
    {m : ℕ} [Fact (Nat.Prime m)] [NeZero m]
    (hm : m ≥ 2) (P : CycleProfile m)
    (h_realizable : P.isRealizable)
    (hSm : m ∣ P.S)
    (h_geqj : ∀ j : Fin m, (P.S / m) * j.val ≤ P.partialSum j)
    (h_wbdd : ∀ j : Fin m, weightsForBase P (P.S / m) h_geqj j ≤ 2 ^ (P.S / m) - 1) :
    ∃ K, ∀ j, weightsForBase P (P.S / m) h_geqj j = K := by
  -- From `h_realizable`, `D = b^m - 3^m >  �0�`, so ` �b� > 3`.
  have hb_gt_3 : (2 ^ (P.S / m) :) > 3 := by
    have := h_realizable.1;
    unfold cycleDenominator at this;
    contrapose! this;
    rw [ show P.S = m * ( P.S / m ) by rw [ Nat.mul_div_cancel' hSm ] ] ; norm_num [ pow_mul ];
    rw [ ← pow_mul, mul_comm, pow_mul ] ; gcongr;
    exact_mod_cast this;
  -- From `evalSum_multiple_of �_D�`, there exists `k` such that `evalSumGeneral m (2 ^ (P.S / m)) (weightsForBase P (P.S / m) h_geqj) = k * (2 ^ (P.S / m) ^ m - 3 ^ m)`.
  obtain ⟨k, hk⟩ : ∃ k : ℤ, evalSumGeneral m (2 ^ (P.S / m)) (weightsForBase P (P.S / m) h_geqj) = k * ((2 ^ (P.S / m) :) ^ m - 3 ^ m) := by
    have h_evalSum : evalSumGeneral m (2 ^ (P.S / m)) (weightsForBase P (P.S / m) h_geqj) = P.waveSum := by
      exact?;
    have h_div : (cycleDenominator m P.S : ℤ) ∣ P.waveSum := by
      exact h_realizable.2;
    convert h_div using 1;
    rw [ ← h_evalSum ];
    unfold cycleDenominator; norm_num [ ← pow_mul, Nat.mul_div_cancel' hSm ] ;
    rw [ Nat.div_mul_cancel hSm ] ; norm_num [ dvd_iff_exists_eq_mul_left ] ;
  -- From `weights_constant_aux`, there exists `k` such that `weightsForBase P (P.S / m) h_geqj j = k * (2 ^ � (�P.S / m) - 3)` for all `j`.
  have h_constant : ∀ j : Fin m, weightsForBase P (P.S / m) h_geqj j = k * (2 ^ (P.S / m) - 3) := by
    apply_rules [ weights_constant_aux ];
    · grind;
    · exact_mod_cast Nat.Coprime.pow_left _ ( by decide );
    · exact fun i => lt_of_le_of_lt ( Nat.cast_le.mpr ( h_wbdd i ) ) ( by rw [ Nat.cast_sub ] <;> norm_num ; linarith [ pow_pos ( zero_lt_two' ℤ ) ( P.S / m ) ] );
    · aesop;
  exact ⟨ Int.toNat ( k * ( 2 ^ ( P.S / m ) - 3 ) ), fun j => by rw [ ← h_constant j, Int.toNat_natCast ] ⟩

lemma constant_weights_imp_constant_nu
    {m : ℕ} (hm : m ≥ 2) (P : CycleProfile m)
    (hSm : m ∣ P.S)
    (h_geqj : ∀ j : Fin m, (P.S / m) * j.val ≤ P.partialSum j)
    (K : ℕ)
    (h_weights : ∀ j, weightsForBase P (P.S / m) h_geqj j = K) :
    ∀ j, P.ν j = P.S / m := by
  -- By definition of $weightsForBase$, we know that $2^{S_j - q*j} = K$ for all $j$.
  have h_exp : ∀ j : Fin m, 2 ^ (P.partialSum j - (P.S / m) * j.val) = K := by
    exact fun j => h_weights j ▸ rfl;
  -- Since $2^{S_j - q*j} = K$ for all $j$, and $K$ is constant, it follows that $S_j - q*j$ � is� constant.
  have h_const_diff : ∀ j : Fin m, P.partialSum j - (P.S / m) * j.val = P.partialSum ⟨0, by linarith⟩ - (P.S / m) * 0 := by
    intro j; have := h_exp j; have := h_exp ⟨ 0, by linarith ⟩ ; aesop;
  -- Since $S_j - q*j$ is constant, we have $S_j = q*j + C$ for some constant $C$.
  have h_partial_sum : ∀ j : Fin m, P.partialSum j = (P.S / m) * j.val + P.partialSum ⟨0, by linarith⟩ := by
    intro j;
    exact?;
  rcases m with ( _ | _ | m ) <;> norm_num at *;
  · contradiction;
  · intro j; have := h_partial_sum j; have := h_partial_sum ( j + 1 ) ; norm_num at *;
    by_cases hj : j.val < m + 1;
    · norm_num [ Fin.val_add, Nat.mod_eq_of_lt ( by linarith : ( j : ℕ ) + 1 < m + 1 + 1 ) ] at *;
      rw [ show P.partialSum ( j + 1 ) = P.partialSum j + P.ν j from ?_ ] at this;
      · linarith;
      · unfold CycleProfile.partialSum; simp +decide [ Finset.sum_filter, Finset.sum_range_succ ] ;
        rw [ Finset.sum_eq_add_sum_diff_singleton ( Finset.mem_univ j ) ];
        rw [ Finset.sum_eq_add_sum_diff_singleton ( Finset.mem_univ j ) ] ; simp +decide [ Finset.sum_ite, Finset.filter_lt_eq_Ioi ] ; ring;
        rw [ if_pos ( by simpa [ Fin.lt_iff_val_lt_val ] using hj ), add_comm ];
        congr! 1;
        refine' Finset.sum_subset _ _ <;> simp +contextual [ Finset.subset_iff ];
        · intro x hx₁ hx₂; contrapose! hx₁; simp +decide [ Fin.add_def, Nat.mod_eq_of_lt ( by linarith : ( j : ℕ ) + 1 < m + 1 + 1 ) ] at *;
          exact le_antisymm ( Nat.le_of_lt_succ hx₂ ) hx₁;
        · intro x hx₁ hx₂ hx; contrapose! hx; simp +decide [ Fin.add_def, Nat.mod_eq_of_lt ( show ( j : ℕ ) + 1 < m + 1 + 1 from by linarith ) ] at *;
          exact Nat.lt_succ_of_lt hx₂;
    · norm_num [ show j = Fin.last _ from le_antisymm ( Fin.le_last _ ) ( not_lt.mp hj ) ] at *;
      have := P.sum_ν; simp +decide [ Fin.sum_univ_castSucc ] at this;
      unfold CycleProfile.partialSum at *; simp +decide [ Fin.sum_univ_castSucc ] at *;
      rw [ show ( Finset.univ.filter fun i : Fin ( m + 1 + 1 ) => i < Fin.last ( m + 1 ) ) = Finset.image ( fun i : Fin ( m + 1 ) => Fin.castSucc i ) Finset.univ from ?_, Finset.sum_image <| by intros a ha b hb hab; simpa [ Fin.ext_iff ] using hab ] at this ; simp +decide [ Fin.sum_univ_castSucc ] at this ⊢ ; linarith [ Nat.div_mul_cancel hSm ];
      ext i; simp +decide [ Fin.lt_iff_val_lt_val ] ;
      exact ⟨ fun hi => ne_of_lt hi, fun hi => lt_of_le_of_ne ( Fin.le_last _ ) ( by simpa [ Fin.ext_iff ] using hi ) ⟩

theorem nontrivial_not_realizable_prime_quotient
    {m : ℕ} [Fact (Nat.Prime m)] [NeZero m]
    (hm : m ≥ 2) (P : CycleProfile m)
    (h_nontrivial : P.isNontrivial)
    (h_realizable : P.isRealizable)
    (hSm : m ∣ P.S)
    (h_geqj : ∀ j : Fin m, (P.S / m) * j.val ≤ P.partialSum j)
    (h_wbdd : ∀ j : Fin m, weightsForBase P (P.S / m) h_geqj j ≤ 2 ^ (P.S / m) - 1) :
    False := by
  -- By `weights_constant`, there exists � `�K` such that `weightsForBase ... = K` for all `j`.
  obtain ⟨K, hK⟩ := weights_constant hm P h_realizable hSm h_geqj h_wbdd;
  -- Apply `constant_weights_imp_constant_nu` with `hK` to get `∀ j, P.ν j = P.S / m`.
  have h_nu_const : ∀ j, P.ν j = P.S / m := by
    apply constant_weights_imp_constant_nu hm P hSm h_geqj K hK;
  cases h_nontrivial ; aesop
/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f57401ec-aa77-4d79-9029-e89e95b160bb

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 79dd1705-ecb5-4fd5-a45d-6f484b39b7d0

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

-- 2-adic valuation (using multiplicity)
noncomputable def v2 (n : ℕ) : ℕ := multiplicity 2 n

-- Syracuse map: apply 3n+1 then strip all factors of 2
noncomputable def collatzOdd (n : ℕ) : ℕ :=
  (3 * n + 1) / 2 ^ v2 (3 * n + 1)

-- k-fold Syracuse iteration
noncomputable def collatzOddIter : ℕ → ℕ → ℕ
  | 0, n => n
  | k + 1, n => collatzOddIter k (collatzOdd n)

-- Iteration commutes: T^{k+1}(n) = T(T^k(n))
lemma collatzOddIter_succ_right (k n : ℕ) :
    collatzOddIter (k + 1) n = collatzOdd (collatzOddIter k n) := by
  induction k generalizing n with
  | zero => rfl
  | succ k ih =>
    show collatzOddIter (k + 1) (collatzOdd n) = collatzOdd (collatzOddIter (k + 1) n)
    rw [ih (collatzOdd n)]; congr 1

-- Divergent orbit: grows without bound
def OddOrbitDivergent (n₀ : ℕ) : Prop :=
  ∀ B : ℕ, ∃ m : ℕ, collatzOddIter m n₀ > B

-- Per-step halving count (ν_j)
noncomputable def orbitNu (x j : ℕ) : ℕ := v2 (3 * collatzOddIter j x + 1)

-- Cumulative halvings over k steps
noncomputable def orbitS (x k : ℕ) : ℕ := ∑ j ∈ Finset.range k, orbitNu x j

-- Wavesum (carry) over k steps
noncomputable def orbitC (n : ℕ) : ℕ → ℕ
  | 0 => 0
  | k + 1 => 3 * orbitC n k + 2 ^ orbitS n k

-- Residue-based lower bound for v₂(3n+1)
def etaResidue (n : ℕ) : ℕ :=
  if n % 8 = 1 then 2 else if n % 8 = 5 then 3 else 1

-- Standard Collatz map
def collatz (n : ℕ) : ℕ :=
  if n % 2 = 0 then n / 2 else 3 * n + 1

-- k-fold iteration of the standard Collatz map
def collatzIter : ℕ → ℕ → ℕ
  | 0, n => n
  | k + 1, n => collatzIter k (collatz n)

-- etaResidue is a lower bound for v₂(3n+1) when n is odd
lemma etaResidue_le_v2_of_odd (n : ℕ) (hn : Odd n) :
    etaResidue n ≤ v2 (3 * n + 1) := by
  obtain ⟨ k, rfl ⟩ : ∃ k, n = 2 * k + 1 := hn;
  -- Let's simplify the expression $3 * (2 * k + 1) + 1$ modulo 8.
  have h_mod : 3 * (2 * k + 1) + 1 ≡ 0 [MOD 2 ^ (if (2 * k + 1) % 8 = 1 then 2 else if (2 * k + 1) % 8 = 5 then 3 else 1)] := by
    split_ifs <;> rw [ Nat.ModEq ] <;> omega;
  convert Nat.le_of_not_lt fun h => absurd ( Nat.dvd_trans ( pow_dvd_pow _ h ) ( Nat.dvd_of_mod_eq_zero h_mod ) ) _ using 1;
  convert Nat.pow_succ_factorization_not_dvd ( by linarith : ( 3 * ( 2 * k + 1 ) + 1 ) ≠ 0 ) Nat.prime_two using 1;
  unfold v2; norm_num;
  rw [ Nat.factorization_def ];
  · rw [ padicValNat_def ] ; aesop;
  · norm_num

-- The EXACT orbit equation: x_{k} · 2^{S_k} = 3^k · x + C_k
theorem orbit_iteration_formula (x : ℕ) (h_odd : Odd x) (h_pos : 0 < x) (k : ℕ) :
    collatzOddIter k x * 2 ^ orbitS x k = 3 ^ k * x + orbitC x k := by
  induction' k with k ih generalizing x <;> simp_all +decide [ pow_succ', Finset.sum_range_succ ];
  · -- By definition of collatzOddIter and orbitS, we have collatzOddIter 0 x = x and orbitS x 0 = 0.
    simp [collatzOddIter, orbitS, orbitC];
  · -- Let's simplify the expression for the next step in the iteration.
    have h_step : collatzOddIter (k + 1) x = (3 * collatzOddIter k x + 1) / 2 ^ (v2 (3 * collatzOddIter k x + 1)) := by
      rw [ collatzOddIter_succ_right ];
      rfl;
    -- Let's simplify the expression for the next step in the iteration using the definition of `orbitC`.
    have h_orbitC_step : orbitC x (k + 1) = 3 * orbitC x k + 2 ^ (orbitS x k) := by
      exact?;
    -- Let's simplify the expression for the next step in the iteration using the definition of `orbitS`.
    have h_orbitS_step : orbitS x (k + 1) = orbitS x k + v2 (3 * collatzOddIter k x + 1) := by
      exact Finset.sum_range_succ _ _
    simp_all +decide [ pow_add, mul_assoc, mul_comm, mul_left_comm ];
    rw [ Nat.mul_div_cancel' ];
    · linarith [ ih x h_odd h_pos ];
    · -- By definition of $v2$, we know that $2^{v2(n)}$ divides $n$ for any $n$.
      have h_div : ∀ n : ℕ, 2 ^ (multiplicity 2 n) ∣ n := by
        exact?;
      exact h_div _

-- 2 * C_k ≤ (3^k - 1) * 2^{S_k}
lemma orbitC_le_wavesum_bound (x k : ℕ) :
    2 * orbitC x k ≤ (3 ^ k - 1) * 2 ^ orbitS x k := by
  -- By induction on $k$, we can show that $2 * orbitC x k \leq (3^k - 1) * 2 ^ orbitS x k$.
  have h_ind : ∀ k, 2 * orbitC x k ≤ (3^k - 1) * 2 ^ orbitS x k := by
    intro k;
    induction' k with k ih <;> norm_num [ Nat.pow_succ', orbitC, orbitS ] at *;
    rw [ Finset.sum_range_succ ];
    rw [ pow_add ];
    rw [ tsub_mul ];
    refine' le_tsub_of_add_le_left _;
    nlinarith [ Nat.sub_add_cancel ( Nat.one_le_pow k 3 zero_lt_three ), pow_pos ( show 0 < 2 by decide ) ( ∑ j ∈ Finset.range k, orbitNu x j ), pow_pos ( show 0 < 2 by decide ) ( orbitNu x k ), pow_pos ( show 0 < 3 by decide ) k, mul_le_mul_left' ( Nat.one_le_pow ( orbitNu x k ) 2 ( by decide ) ) ( 2 ^ ∑ j ∈ Finset.range k, orbitNu x j ) ];
  exact?

-- Each Syracuse step less than doubles: T(n) < 2n for odd n > 0
lemma collatzOdd_lt_two_mul (n : ℕ) (hn : Odd n) (hn_pos : 0 < n) :
    collatzOdd n < 2 * n := by
  -- Since $n$ is odd, $3n + 1$ is even, and we can write $3n + 1 = 2^k \cdot m$ where $m$ is odd and $k \geq 1$.
  obtain ⟨k, m, hm⟩ : ∃ k m, 3 * n + 1 = 2 ^ k * m ∧ Odd m ∧ k ≥ 1 := by
    use Nat.factorization (3 * n + 1) 2, (3 * n + 1) / 2 ^ Nat.factorization (3 * n + 1) 2;
    -- Since $3n + 1$ is even, the exponent of 2 in its prime factorization is at least 1.
    have h_exp : (Nat.factorization (3 * n + 1)) 2 ≥ 1 := by
      exact Nat.pos_of_ne_zero fun h => by simp_all +decide [ Nat.factorization, ← even_iff_two_dvd, parity_simps ] ;
    exact ⟨ Eq.symm ( Nat.mul_div_cancel' ( Nat.ordProj_dvd _ _ ) ), by rw [ Nat.odd_iff ] ; exact Nat.mod_two_ne_zero.mp fun h => absurd ( Nat.dvd_of_mod_eq_zero h ) ( Nat.not_dvd_ordCompl ( by norm_num ) <| by aesop ), h_exp ⟩;
  -- By definition of collatzOdd, we have collatzOdd n = (3 * n + 1) / 2 ^ k.
  have h_collatzOdd_def : collatzOdd n = (3 * n + 1) / 2 ^ k := by
    -- By definition of $collatzOdd$, we have $collatzOdd n = (3n + 1) / 2^{v2(3n + 1)}$.
    have h_collatzOdd_def : collatzOdd n = (3 * n + 1) / 2 ^ (multiplicity 2 (3 * n + 1)) := by
      rfl;
    rw [ h_collatzOdd_def, hm.1, multiplicity_eq_of_dvd_of_not_dvd ];
    · norm_num;
    · rw [ pow_add, mul_dvd_mul_iff_left ( by positivity ) ] ; simp_all +decide [ ← even_iff_two_dvd, parity_simps ];
  rcases k with ( _ | _ | k ) <;> simp_all +decide [ Nat.pow_succ', Nat.mul_assoc ];
  · grind;
  · rw [ Nat.div_lt_iff_lt_mul <| by positivity ] ; nlinarith [ pow_pos ( zero_lt_two' ℕ ) k, hm.2.pos ]

-- Contraction: x ≥ 3^20 ∧ S₂₀ ≥ 33 → x₊₂₀ < x
theorem contraction_20step (x : ℕ) (h_odd : Odd x) (h_pos : 0 < x)
    (h_nu : 33 ≤ orbitS x 20) (h_large : x ≥ 3 ^ 20) :
    collatzOddIter 20 x < x := by
  -- Using the exact orbit equation, we have $x_{20} \cdot 2^{S_{20}} = 3^{20} \cdot x + C_{20}$.
  have h_exact : collatzOddIter 20 x * 2 ^ orbitS x 20 = 3 ^ 20 * x + orbitC x 20 := by
    exact orbit_iteration_formula x h_odd h_pos 20;
  -- Using the bound on $C_{20}$, we have $2 * C_{20} \leq (3^{20} - 1) * 2^{S_{20}}$.
  have h_C_bound : 2 * orbitC x 20 ≤ (3 ^ 20 - 1) * 2 ^ orbitS x 20 := by
    -- Apply the lemma orbitC_le_wavesum_bound with k = 20.
    apply orbitC_le_wavesum_bound;
  norm_num +zetaDelta at *;
  -- Since $S_{20} \geq 33$, we have $2^{S_{20}} \geq 2^{33}$.
  have h_exp : 2 ^ orbitS x 20 ≥ 2 ^ 33 := by
    exact pow_le_pow_right₀ ( by decide ) h_nu;
  nlinarith only [ h_exact, h_C_bound, h_exp, h_large ]

-- Below 3^20 stays below 3^20 (when S₂₀ ≥ 33)
theorem checkpoint_below_stays_below (x : ℕ) (h_odd : Odd x) (h_pos : 0 < x)
    (h_nu : 33 ≤ orbitS x 20) (h_small : x < 3 ^ 20) :
    collatzOddIter 20 x < 3 ^ 20 := by
  -- Using the bound from Lemma 2, we have $3^{20} * x + C_{20} \leq 3^{20} * x + (3^{20} - 1) * 2^{S_{20}} / 2$.
  have h_bound : 3 ^ 20 * x + orbitC x 20 < 2 ^ orbitS x 20 * 3 ^ 20 := by
    have := orbitC_le_wavesum_bound x 20;
    -- Since $orbitS x 20 \geq 33$, we have $2^{orbitS x 20} \geq 2^{33}$.
    have h_exp : 2 ^ orbitS x 20 ≥ 2 ^ 33 := by
      exact Nat.pow_le_pow_right ( by decide ) h_nu;
    grind;
  nlinarith [ show collatzOddIter 20 x * 2 ^ orbitS x 20 = 3 ^ 20 * x + orbitC x 20 from orbit_iteration_formula x h_odd h_pos 20, Nat.one_le_pow ( orbitS x 20 ) 2 zero_lt_two ]

-- f^j(f^m(n)) = f^{m+j}(n)
lemma collatzOddIter_comp (m j n₀ : ℕ) :
    collatzOddIter j (collatzOddIter m n₀) = collatzOddIter (m + j) n₀ := by
  -- By induction on $j$, we can show that $collatzOddIter j (collatzOddIter m n₀) = collatzOddIter (m + j) n₀$.
  induction' j with j ih generalizing m n₀;
  · rfl;
  · simp_all +decide [ ← add_assoc, collatzOddIter_succ_right ]

-- k-fold iteration grows at most 2^k
lemma collatzOddIter_le_two_pow_mul (n : ℕ) (hn : Odd n) (hn_pos : 0 < n) (k : ℕ) :
    collatzOddIter k n ≤ 2 ^ k * n := by
  induction' k with k ih generalizing n <;> simp_all +decide [ pow_succ', mul_assoc, collatzOddIter ];
  -- Since collatzOdd n is odd, we can apply the induction hypothesis to get collatzOddIter k (collatzOdd n) ≤ 2^k * collatzOdd n.
  have h_induct : collatzOddIter k (collatzOdd n) ≤ 2^k * collatzOdd n := by
    apply ih;
    · unfold collatzOdd;
      -- By definition of $v2$, we know that $2^{v2(3n+1)}$ divides $3n+1$, but $2^{v2(3n+1)+1}$ does not.
      have h_div : 2 ^ v2 (3 * n + 1) ∣ 3 * n + 1 ∧ ¬2 ^ (v2 (3 * n + 1) + 1) ∣ 3 * n + 1 := by
        have h_div : v2 (3 * n + 1) = Nat.factorization (3 * n + 1) 2 := by
          unfold v2;
          rw [ Nat.multiplicity_eq_factorization ] ; norm_num;
          positivity;
        exact ⟨ h_div.symm ▸ Nat.ordProj_dvd _ _, h_div.symm ▸ Nat.pow_succ_factorization_not_dvd ( by positivity ) ( by norm_num ) ⟩;
      exact Nat.odd_iff.mpr ( Nat.mod_two_ne_zero.mp fun h => h_div.2 <| by convert Nat.mul_dvd_mul_left ( 2 ^ v2 ( 3 * n + 1 ) ) ( Nat.dvd_of_mod_eq_zero h ) using 1; rw [ Nat.mul_div_cancel' h_div.1 ] );
    · -- Since $3n + 1$ is even, dividing by $2^{v2(3n + 1)}$ gives an odd number, which is positive.
      have h_odd : Odd ((3 * n + 1) / 2 ^ v2 (3 * n + 1)) := by
        -- By definition of $v2$, we know that $2^{v2(3n+1)}$ divides $3n+1$, but $2^{v2(3n+1)+1}$ does not.
        have h_div : 2 ^ v2 (3 * n + 1) ∣ 3 * n + 1 ∧ ¬2 ^ (v2 (3 * n + 1) + 1) ∣ 3 * n + 1 := by
          have h_div : v2 (3 * n + 1) = Nat.factorization (3 * n + 1) 2 := by
            unfold v2;
            rw [ Nat.multiplicity_eq_factorization ] ; norm_num;
            positivity;
          exact ⟨ h_div.symm ▸ Nat.ordProj_dvd _ _, h_div.symm ▸ Nat.pow_succ_factorization_not_dvd ( by positivity ) ( by norm_num ) ⟩;
        exact Nat.odd_iff.mpr ( Nat.mod_two_ne_zero.mp fun h => h_div.2 <| by convert Nat.mul_dvd_mul_left ( 2 ^ v2 ( 3 * n + 1 ) ) ( Nat.dvd_of_mod_eq_zero h ) using 1; rw [ Nat.mul_div_cancel' h_div.1 ] );
      exact Nat.pos_of_ne_zero h_odd.pos.ne';
  -- Since collatzOdd n is less than or equal to 2n, we can substitute this into our inequality.
  have h_collatzOdd_le : collatzOdd n ≤ 2 * n := by
    exact le_of_lt ( collatzOdd_lt_two_mul n hn hn_pos );
  nlinarith [ pow_pos ( zero_lt_two' ℕ ) k ]

-- Cycle denominator: D = 2^S − 3^m
def cycleDenominator (m S : ℕ) : ℤ := (2 : ℤ) ^ S - 3 ^ m

-- Cycle profile: ν j is the halvings at step j, S = ∑ νⱼ
structure CycleProfile (m : ℕ) where
  ν : Fin m → ℕ
  ν_pos : ∀ j, ν j ≥ 1
  S : ℕ
  sum_ν : ∑ j : Fin m, ν j = S

-- Partial sum: S_j = ν₀ + ⋯ + ν_{j−1}
def CycleProfile.partialSum {m : ℕ} (P : CycleProfile m) (j : Fin m) : ℕ :=
  ∑ i ∈ Finset.univ.filter (· < j), P.ν i

-- Wave sum: W = ∑_j 3^{m−1−j} · 2^{S_j}
def CycleProfile.waveSum {m : ℕ} (P : CycleProfile m) : ℕ :=
  ∑ j : Fin m, 3 ^ (m - 1 - j.val) * 2 ^ (P.partialSum j)

-- Realizable: D > 0 and D | W
def CycleProfile.isRealizable {m : ℕ} (P : CycleProfile m) : Prop :=
  cycleDenominator m P.S > 0 ∧ (cycleDenominator m P.S : ℤ) ∣ (P.waveSum : ℤ)

-- Nontrivial: some νⱼ values differ
def CycleProfile.isNontrivial {m : ℕ} (P : CycleProfile m) : Prop := ∃ j k : Fin m, P.ν j ≠ P.ν k

-- Baker's theorem for cycle profiles: |S - m·log₂3| > 0
theorem baker_lower_bound {m : ℕ} (P : CycleProfile m) (hm : m ≥ 2)
    (_hnontrivial : P.isNontrivial) :
    ∃ c : ℝ, ∃ K : ℕ, c > 0 ∧
      |((P.S : ℝ) - (m : ℝ) * Real.log 3 / Real.log 2)| ≥ c / ((m : ℝ) ^ K) := by
  by_cases h : (P.S : ℝ) - m * Real.log 3 / Real.log 2 = 0;
  · -- If $S = m \cdot \frac{\log 3}{\log 2}$, then $2^S = 3^m$, which contradicts the assumption that $D = 2^S - 3^m > 0$.
    have h_contradiction : (2 : ℝ) ^ P.S = 3 ^ m := by
      rw [ sub_eq_zero, eq_div_iff ] at h <;> norm_num at *;
      rw [ ← @Real.exp_log ( 2 ^ P.S ) ( by positivity ), ← @Real.exp_log ( 3 ^ m ) ( by positivity ), Real.log_pow, Real.log_pow ] ; aesop;
    norm_cast at *;
    apply_fun fun x => x.factorization 2 at h_contradiction ; simp_all +decide;
    grind;
  · exact ⟨ |↑P.S - ↑m * Real.log 3 / Real.log 2|, 0, abs_pos.mpr h, by norm_num ⟩

def BakerWindowDriftProperty (n₀ : ℕ) : Prop :=
  ∃ M₀ : ℕ, ∃ delta : ℕ, 0 < delta ∧
    ∀ M : ℕ, M₀ ≤ M → delta ≤ orbitS (collatzOddIter M n₀) 20 - 32

def BakerGapBoundProperty : Prop :=
  ∀ (S m : ℕ), m ≥ 2 → S ≥ 1 → (2 : ℤ)^S > 3^m →
    (2 : ℤ)^S - 3^m ≥ 3^m / m ^ 10

def MinNontrivialCycleLengthProperty : Prop :=
  ∀ {m : ℕ} (P : CycleProfile m), P.isNontrivial → (72000000000 : ℕ) ≤ m

def MinNontrivialCycleStartProperty : Prop :=
  ∀ {m : ℕ} (hm : m ≥ 2) (P : CycleProfile m) (h_nontrivial : P.isNontrivial)
    (hD_pos : cycleDenominator m P.S > 0) (n₀ : ℤ)
    (hn₀ : (P.waveSum : ℤ) = (cycleDenominator m P.S) * n₀),
    n₀ ≥ 2 ^ 71

def MinNontrivialCycleLengthProperty' : Prop :=
  ∀ {m : ℕ} (P : CycleProfile m), P.isNontrivial → P.isRealizable → (72000000000 : ℕ) ≤ m

structure CollatzAxioms : Prop where
  baker_window_drift : ∀ (n₀ : ℕ), n₀ > 1 → Odd n₀ → OddOrbitDivergent n₀ → BakerWindowDriftProperty n₀
  baker_gap_bound : BakerGapBoundProperty
  min_nontrivial_cycle_length : MinNontrivialCycleLengthProperty'
  min_nontrivial_cycle_start : MinNontrivialCycleStartProperty

theorem supercritical_rate (n₀ : ℕ) (h_n₀ : n₀ > 1) (h_odd : Odd n₀)
    (h_div : OddOrbitDivergent n₀)
    (h_baker : BakerWindowDriftProperty n₀) :
    ∃ M₀ : ℕ, ∀ M : ℕ, M₀ ≤ M →
      33 ≤ orbitS (collatzOddIter M n₀) 20 := by
  cases' h_baker with M₀ hM₀;
  exact ⟨ M₀, fun M hM => by obtain ⟨ delta, hdelta_pos, hdelta ⟩ := hM₀; linarith [ hdelta M hM, Nat.sub_add_cancel ( show 32 ≤ orbitS ( collatzOddIter M n₀ ) 20 from le_of_lt ( Nat.lt_of_sub_pos ( by linarith [ hdelta M hM ] ) ) ) ] ⟩

lemma checkpoints_bounded (n₀ m₁ : ℕ) (h_odd : Odd n₀) (h_pos : 0 < n₀)
    (h_rate : ∀ M : ℕ, m₁ ≤ M → 33 ≤ orbitS (collatzOddIter M n₀) 20) :
    ∀ k, collatzOddIter (m₁ + 20 * k) n₀ ≤ max (collatzOddIter m₁ n₀) (3 ^ 20) := by
      intro k; induction' k with k ih <;> simp_all +decide [ Nat.mul_succ, ← add_assoc ] ;
      -- By definition of $collatzOddIter$, we have $collatzOddIter (m₁ + 20 * k + 20) n₀ = collatzOddIter 20 (collatzOddIter (m₁ + 20 * k) n₀)$.
      have h_iter : collatzOddIter (m₁ + 20 * k + 20) n₀ = collatzOddIter 20 (collatzOddIter (m₁ + 20 * k) n₀) := by
        exact?;
      -- By the contraction_20step lemma, if the orbit at step m₁ + 20*k is at least 3^20, then after 20 steps, it will be less than itself. Otherwise, it will be less than 3^20.
      have h_contraction : ∀ x : ℕ, Odd x → 0 < x → 33 ≤ orbitS x 20 → collatzOddIter 20 x < x ∨ collatzOddIter 20 x < 3 ^ 20 := by
        intros x hx_odd hx_pos hx_rate; exact (by
        exact Classical.or_iff_not_imp_left.2 fun h => by have := contraction_20step x hx_odd hx_pos hx_rate; have := checkpoint_below_stays_below x hx_odd hx_pos hx_rate; norm_num at * ; omega;);
      -- By definition of $collatzOddIter$, we know that $collatzOddIter (m₁ + 20 * k) n₀$ is odd and positive.
      have h_odd_pos : Odd (collatzOddIter (m₁ + 20 * k) n₀) ∧ 0 < collatzOddIter (m₁ + 20 * k) n₀ := by
        have h_odd_pos : ∀ m : ℕ, Odd (collatzOddIter m n₀) ∧ 0 < collatzOddIter m n₀ := by
          -- We proceed by induction on $m$.
          intro m
          induction' m with m ih;
          · exact ⟨ h_odd, h_pos ⟩;
          · -- Since $3 * collatzOddIter m n₀ + 1$ is even, dividing by $2^{v2(3 * collatzOddIter m n₀ + 1)}$ results in an odd number.
            have h_odd : Odd (collatzOdd (collatzOddIter m n₀)) := by
              have h_odd : ¬(2 ∣ (3 * collatzOddIter m n₀ + 1) / 2 ^ v2 (3 * collatzOddIter m n₀ + 1)) := by
                rw [ Nat.Prime.dvd_iff_one_le_factorization ] <;> norm_num;
                · rw [ Nat.factorization_div ] <;> norm_num;
                  · -- By definition of $v2$, we know that $v2(n) = \text{Nat.factorization } n 2$.
                    simp [v2];
                    rw [ Nat.sub_eq_zero_of_le ];
                    rw [ Nat.multiplicity_eq_factorization ] ; norm_num;
                    positivity;
                  · -- By definition of multiplicity, $2^{v2(n)}$ divides $n$ for any integer $n$.
                    have h_div : ∀ n : ℕ, 2 ^ multiplicity 2 n ∣ n := by
                      exact?;
                    exact h_div _;
                · -- By definition of multiplicity, $2^{v2(n)}$ divides $n$, so $2^{v2(n)} \leq n$.
                  have h_div : 2 ^ v2 (3 * collatzOddIter m n₀ + 1) ∣ 3 * collatzOddIter m n₀ + 1 := by
                    -- By definition of multiplicity, $2^{v2(n)}$ divides $n$ for any integer $n$.
                    have h_div : ∀ n : ℕ, 2 ^ multiplicity 2 n ∣ n := by
                      exact?;
                    exact h_div _;
                  exact Nat.le_of_dvd ( Nat.succ_pos _ ) h_div;
              exact Nat.odd_iff.mpr ( Nat.mod_two_ne_zero.mp fun h => h_odd <| Nat.dvd_of_mod_eq_zero h );
            exact ⟨ by simpa only [ collatzOddIter_succ_right ] using h_odd, by simpa only [ collatzOddIter_succ_right ] using h_odd.pos ⟩;
        exact h_odd_pos _;
      grind +ring

lemma checkpoints_bounded_v2 (n₀ m₁ : ℕ) (h_odd : Odd n₀) (h_pos : 0 < n₀)
    (h_rate : ∀ M : ℕ, m₁ ≤ M → 33 ≤ orbitS (collatzOddIter M n₀) 20) :
    ∀ k, collatzOddIter (m₁ + 20 * k) n₀ ≤ max (collatzOddIter m₁ n₀) (3 ^ 20) := by
  convert checkpoints_bounded n₀ m₁ h_odd h_pos h_rate using 1

lemma orbit_bounded_of_checkpoints_bounded (n₀ m₁ B : ℕ) (h_odd : Odd n₀) (h_pos : 0 < n₀)
    (h_checkpoints : ∀ k, collatzOddIter (m₁ + 20 * k) n₀ ≤ B) :
    ∀ m, m₁ ≤ m → collatzOddIter m n₀ ≤ 2 ^ 19 * B := by
      intro m hm;
      -- By definition of $collatzOddIter$, we know that $collatzOddIter m n₀ \leq 2^{m - (m₁ + 20 * k)} * collatzOddIter (m₁ + 20 * k) n₀$ for any $k$ such that $m₁ + 20 * k \leq m$.
      obtain ⟨k, hk⟩ : ∃ k : ℕ, m₁ + 20 * k ≤ m ∧ m < m₁ + 20 * (k + 1) := by
        exact ⟨ ( m - m₁ ) / 20, by omega, by omega ⟩;
      -- Using the definition of $collatzOddIter$, we can write $collatzOddIter m n₀$ as $collatzOddIter (m - (m₁ + 20 * k)) (collatzOddIter (m₁ + 20 * k) n₀)$.
      have h_iter : collatzOddIter m n₀ = collatzOddIter (m - (m₁ + 20 * k)) (collatzOddIter (m₁ + 20 * k) n₀) := by
        rw [ ← collatzOddIter_comp ];
        -- By definition of collatzOddIter, we can rewrite the right-hand side as collatzOddIter (m - (m₁ + 20 * k) + 20 * k + m₁) n₀.
        have h_assoc : collatzOddIter (m - (m₁ + 20 * k)) (collatzOddIter (20 * k) (collatzOddIter m₁ n₀)) = collatzOddIter (m - (m₁ + 20 * k) + 20 * k + m₁) n₀ := by
          have h_assoc : ∀ a b c : ℕ, collatzOddIter a (collatzOddIter b (collatzOddIter c n₀)) = collatzOddIter (a + b + c) n₀ := by
            intros a b c; induction' a with a ih generalizing b c <;> simp_all +decide [ Nat.succ_add, collatzOddIter_succ_right ] ;
            induction' b with b ih generalizing c <;> simp_all +decide [ Nat.succ_add, collatzOddIter_succ_right ];
            · rfl;
            · exact ih c ▸ rfl;
          exact h_assoc _ _ _;
        rw [ h_assoc, show m - ( m₁ + 20 * k ) + 20 * k + m₁ = m by linarith [ Nat.sub_add_cancel hk.1 ] ];
      -- Using the definition of $collatzOddIter$, we can write $collatzOddIter (m - (m₁ + 20 * k)) (collatzOddIter (m₁ + 20 * k) n₀)$ as $collatzOddIter (m - (m₁ + 20 * k)) (collatzOddIter (m₁ + 20 * k) n₀)$.
      have h_iter_bound : collatzOddIter (m - (m₁ + 20 * k)) (collatzOddIter (m₁ + 20 * k) n₀) ≤ 2 ^ (m - (m₁ + 20 * k)) * collatzOddIter (m₁ + 20 * k) n₀ := by
        apply collatzOddIter_le_two_pow_mul;
        · -- By definition of collatzOddIter, each step preserves the oddness of the number.
          have h_odd_iter : ∀ k, Odd (collatzOddIter k n₀) := by
            -- By definition of collatzOddIter, each step preserves the oddness of the number. We can prove this by induction on k.
            intro k
            induction' k with k ih;
            · exact h_odd;
            · -- By definition of collatzOdd, if n is odd, then collatzOdd n is also odd.
              have h_collatzOdd_odd : ∀ n, Odd n → Odd (collatzOdd n) := by
                intro n hn_odd
                have h_collatzOdd_odd : Odd ((3 * n + 1) / 2 ^ multiplicity 2 (3 * n + 1)) := by
                  have h_collatzOdd_odd : ¬(2 ∣ (3 * n + 1) / 2 ^ multiplicity 2 (3 * n + 1)) := by
                    rw [ Nat.Prime.dvd_iff_one_le_factorization ] <;> norm_num;
                    · rw [ Nat.factorization ];
                      simp +decide [ multiplicity ];
                      rw [ emultiplicity ];
                      split_ifs <;> simp_all +decide [ padicValNat ];
                      · erw [ WithTop.untopD_coe ] ; aesop;
                      · exact absurd ( ‹∀ x : ℕ, 2 ^ ( x + 1 ) ∣ 3 * n + 1› ( Nat.log 2 ( 3 * n + 1 ) ) ) ( Nat.not_dvd_of_pos_of_lt ( by positivity ) ( Nat.lt_pow_succ_log_self ( by decide ) _ ) );
                    · -- By definition of multiplicity, $2^{multiplicity 2 (3n + 1)}$ divides $3n + 1$, so it must be less than or equal to $3n + 1$.
                      have h_div : 2 ^ multiplicity 2 (3 * n + 1) ∣ 3 * n + 1 := by
                        exact?;
                      exact Nat.le_of_dvd ( Nat.succ_pos _ ) h_div;
                  grind;
                exact h_collatzOdd_odd;
              convert h_collatzOdd_odd _ ih using 1;
              exact?;
          exact h_odd_iter _;
        · -- By definition of $collatzOddIter$, we know that $collatzOddIter (m₁ + 20 * k) n₀$ is odd.
          have h_odd_iter : ∀ k : ℕ, Odd (collatzOddIter k n₀) := by
            -- By definition of collatzOddIter, each step preserves the oddness of the number. We can prove this by induction on k.
            intro k
            induction' k with k ih;
            · exact h_odd;
            · -- By definition of collatzOdd, if n is odd, then collatzOdd n is also odd.
              have h_collatzOdd_odd : ∀ n, Odd n → Odd (collatzOdd n) := by
                intro n hn_odd
                have h_collatzOdd_odd : Odd ((3 * n + 1) / 2 ^ multiplicity 2 (3 * n + 1)) := by
                  have h_collatzOdd_odd : ¬(2 ∣ (3 * n + 1) / 2 ^ multiplicity 2 (3 * n + 1)) := by
                    rw [ Nat.Prime.dvd_iff_one_le_factorization ] <;> norm_num;
                    · rw [ Nat.factorization ];
                      simp +decide [ multiplicity ];
                      rw [ emultiplicity ];
                      split_ifs <;> simp_all +decide [ padicValNat ];
                      · erw [ WithTop.untopD_coe ] ; aesop;
                      · exact absurd ( ‹∀ x : ℕ, 2 ^ ( x + 1 ) ∣ 3 * n + 1› ( Nat.log 2 ( 3 * n + 1 ) ) ) ( Nat.not_dvd_of_pos_of_lt ( by positivity ) ( Nat.lt_pow_succ_log_self ( by decide ) _ ) );
                    · -- By definition of multiplicity, $2^{multiplicity 2 (3n + 1)}$ divides $3n + 1$, so it must be less than or equal to $3n + 1$.
                      have h_div : 2 ^ multiplicity 2 (3 * n + 1) ∣ 3 * n + 1 := by
                        exact?;
                      exact Nat.le_of_dvd ( Nat.succ_pos _ ) h_div;
                  grind;
                exact h_collatzOdd_odd;
              convert h_collatzOdd_odd _ ih using 1;
              exact?;
          exact Nat.pos_of_ne_zero ( by specialize h_odd_iter ( m₁ + 20 * k ) ; aesop );
      exact h_iter.symm ▸ h_iter_bound.trans ( Nat.mul_le_mul ( pow_le_pow_right₀ ( by decide ) ( by omega ) ) ( h_checkpoints k ) )

/-
The Syracuse map preserves oddness (since we divide out all factors of 2).
-/
lemma collatzOdd_odd (n : ℕ) (h_odd : Odd n) (h_pos : 0 < n) :
    Odd (collatzOdd n) := by
  -- Since $3n + 1$ is even, dividing by $2^{v_2(3n + 1)}$ gives an odd number.
  have h_odd_div : ∀ m : ℕ, m ≠ 0 → Odd (m / 2 ^ (Nat.factorization m 2)) := by
    intro m hm; rw [ Nat.odd_iff ] ; exact Nat.mod_two_ne_zero.mp fun contra => absurd ( Nat.dvd_of_mod_eq_zero contra ) ( Nat.not_dvd_ordCompl ( by norm_num ) <| by aesop ) ;
  convert h_odd_div ( 3 * n + 1 ) ( by positivity ) using 1;
  unfold collatzOdd;
  unfold v2;
  rw [ Nat.factorization_def ];
  · rw [ padicValNat_def ] ; aesop;
  · norm_num

/-
Iterated Syracuse map preserves oddness.
-/
lemma collatzOddIter_odd (n₀ : ℕ) (h_odd : Odd n₀) (h_pos : 0 < n₀) (k : ℕ) :
    Odd (collatzOddIter k n₀) := by
  induction k with
  | zero => exact h_odd
  | succ k ih =>
    rw [collatzOddIter_succ_right]
    apply collatzOdd_odd
    · exact ih
    · -- We need to show collatzOddIter k n₀ > 0.
      -- Since n₀ > 0 and collatzOdd preserves positivity for odd numbers, this holds.
      -- But wait, collatzOdd n = (3n+1)/2^v2. If n > 0, 3n+1 > 1, so result > 0.
      -- Since collatzOddIter k n₀ is odd, it cannot be zero.
      apply Nat.pos_of_ne_zero; intro h_zero
      aesop

/-
A divergent orbit exceeds any bound B at some step m ≥ K.
-/
lemma oddOrbitDivergent_unbounded (n₀ : ℕ) (h_div : OddOrbitDivergent n₀) :
    ∀ B K, ∃ m, m ≥ K ∧ collatzOddIter m n₀ > B := by
      intros B K;
      -- By definition of $OddOrbitDivergent$, we know that for any $B$, there exists $m$ such that $collatzOddIter m n₀ > B$.
      have h_B : ∀ B, ∃ m, collatzOddIter m n₀ > B := by
        exact h_div;
      contrapose! h_B;
      exact ⟨ Max.max B ( Finset.sup ( Finset.range K ) fun x => collatzOddIter x n₀ ), fun x => if hx : x < K then le_trans ( Finset.le_sup ( f := fun x => collatzOddIter x n₀ ) ( Finset.mem_range.mpr hx ) ) ( le_max_right _ _ ) else le_trans ( h_B x ( le_of_not_gt hx ) ) ( le_max_left _ _ ) ⟩

/-
The Syracuse orbit of an odd number > 1 does not diverge (assuming Baker's Theorem).
-/
theorem no_divergence (n₀ : ℕ) (h_n₀ : n₀ > 1) (h_odd : Odd n₀) (ax : CollatzAxioms) :
    ¬OddOrbitDivergent n₀ := by
  intro h_div
  -- Step 1: Baker → eventually S₂₀ ≥ 33
  have h_baker_inst := ax.baker_window_drift n₀ h_n₀ h_odd h_div
  obtain ⟨M₀, h_rate⟩ := supercritical_rate n₀ h_n₀ h_odd h_div h_baker_inst

  -- Step 2: Divergence → find m₁ ≥ M₀ with x_{m₁} > 3^20
  obtain ⟨m₁, hm₁_ge, hm₁_val⟩ := oddOrbitDivergent_unbounded n₀ h_div (3^20) M₀

  -- Step 3: Checkpoints descend then stabilize below 3^20
  have h_rate' : ∀ M, m₁ ≤ M → 33 ≤ orbitS (collatzOddIter M n₀) 20 := by
    intro M hM
    apply h_rate
    exact le_trans hm₁_ge hM

  have h_checkpoints := checkpoints_bounded n₀ m₁ h_odd (by linarith) h_rate'

  -- Step 4: Between checkpoints, orbit ≤ 2^19 · checkpoint
  have h_bound_checkpoints : ∀ k, collatzOddIter (m₁ + 20 * k) n₀ ≤ collatzOddIter m₁ n₀ := by
    intro k
    specialize h_checkpoints k
    rw [max_eq_left (le_of_lt hm₁_val)] at h_checkpoints
    exact h_checkpoints

  have h_orbit_bounded := orbit_bounded_of_checkpoints_bounded n₀ m₁ (collatzOddIter m₁ n₀) h_odd (by linarith) h_bound_checkpoints

  -- Step 5: Entire orbit bounded by some B
  -- The tail (m ≥ m₁) is bounded by B_tail = 2^19 * x_{m₁}.
  -- The head (m < m₁) is bounded by B_head = max_{k < m₁} x_k.
  -- So the whole orbit is bounded by max(B_head, B_tail).
  -- This contradicts h_div.
  -- The initial segment $x_m \leq B$ for all $m < m₁$ by definition.
  have h_initial_segment : ∃ B : ℕ, ∀ m < m₁, collatzOddIter m n₀ ≤ B := by
    exact ⟨ Finset.sup ( Finset.range m₁ ) fun m => collatzOddIter m n₀, fun m hm => Finset.le_sup ( f := fun m => collatzOddIter m n₀ ) ( Finset.mem_range.mpr hm ) ⟩;
  -- The overall orbit is bounded by the maximum of the initial segment's bound and the tail bound.
  obtain ⟨B, hB⟩ := h_initial_segment;
  have h_orbit_bounded_final : ∀ m, collatzOddIter m n₀ ≤ max B (2 ^ 19 * collatzOddIter m₁ n₀) := by
    exact fun m => if hm : m < m₁ then le_trans ( hB m hm ) ( le_max_left _ _ ) else le_trans ( h_orbit_bounded m ( le_of_not_gt hm ) ) ( le_max_right _ _ );
  exact absurd ( h_div ( max B ( 2 ^ 19 * collatzOddIter m₁ n₀ ) ) ) ( by rintro ⟨ m, hm ⟩ ; linarith [ h_orbit_bounded_final m ] )

/-
The partial sum S_j is at most S - (m-j).
-/
lemma partialSum_le {m : ℕ} (P : CycleProfile m) (j : Fin m) :
    P.partialSum j ≤ P.S - (m - j.val) := by
  -- P.S - P.partialSum j = sum_{k=j}^{m-1} ν_k
  -- sum_{k=j}^{m-1} ν_k ≥ sum_{k=j}^{m-1} 1 = m - j
  -- So P.S - P.partialSum j ≥ m - j
  -- So P.partialSum j ≤ P.S - (m - j)
  -- The sum of the ν values from j to m-1 is at least (m-j) * 1, which simplifies to m-j.
  have h_sum_ge_mj : ∑ i ∈ Finset.univ.filter (fun i => j ≤ i), P.ν i ≥ m - j.val := by
    exact le_trans ( by simp +decide [ Finset.filter_le_eq_Ici ] ) ( Finset.sum_le_sum fun i hi => P.ν_pos i );
  refine' Nat.le_sub_of_add_le' _;
  rw [ ← P.sum_ν ];
  rw [ ← Finset.sum_filter_add_sum_filter_not ( Finset.univ : Finset ( Fin m ) ) ( fun i => j ≤ i ) ];
  exact add_le_add h_sum_ge_mj ( Finset.sum_le_sum_of_subset <| fun x hx => by aesop )

/-
The wavesum is bounded by 3^m * 2^S.
-/
lemma waveSum_bound {m : ℕ} (hm : m ≥ 1) (P : CycleProfile m) :
    P.waveSum < 3 ^ m * 2 ^ P.S := by
      -- We have W = ∑ 3^{m-1-j} 2^{S_j}. Since S_j ≤ S - (m-j) (by partialSum_le), we have W ≤ ∑ 3^{m-1-j} 2^{S-m+j} = 2^{S-m} ∑ 3^{m-1-j} 2^j.
      have hw_le : P.waveSum ≤ 2^(P.S - m) * ∑ j ∈ Finset.range m, 3^(m-1-j) * 2^j := by
        -- Applying the bound $S_j \leq S - (m-j)$ to each term in the sum.
        have hw_le : ∀ j : Fin m, 3^(m-1-j.val) * 2^(P.partialSum j) ≤ 3^(m-1-j.val) * 2^(P.S - m + j.val) := by
          intro j
          have h_sum_bound : P.partialSum j ≤ P.S - m + j.val := by
            have h_partialSum_le : P.partialSum j ≤ P.S - (m - j.val) := by
              exact?;
            omega
          exact Nat.mul_le_mul_left _ (pow_le_pow_right₀ (by norm_num) h_sum_bound);
        convert Finset.sum_le_sum fun j _ => hw_le j using 1 ; norm_num [ Finset.mul_sum _ _ _, pow_add, mul_assoc, mul_comm, mul_left_comm, Finset.sum_range ];
      -- The sum $\sum_{j=0}^{m-1} 3^{m-1-j} 2^j$ is a geometric series with sum $3^m - 2^m$.
      have h_geo_series : ∑ j ∈ Finset.range m, 3^(m-1-j) * 2^j = 3^m - 2^m := by
        rw [ Nat.sub_eq_of_eq_add ];
        rw [ Nat.sub_eq_of_eq_add ];
        rw [ ← Nat.sub_add_cancel hm, Finset.sum_range_succ' ];
        any_goals exact m - 1;
        · induction m - 1 <;> simp_all +decide [ Finset.sum_range_succ', pow_succ' ] ; ring;
          norm_num [ ← Finset.sum_mul _ _ _ ] ; ring;
        · rw [ Nat.sub_add_cancel hm ];
      refine lt_of_le_of_lt hw_le ?_;
      rw [ h_geo_series, mul_comm ];
      refine' lt_of_lt_of_le ( mul_lt_mul_of_pos_right ( Nat.sub_lt ( by positivity ) ( by positivity ) ) ( by positivity ) ) _;
      exact Nat.mul_le_mul_left _ ( pow_le_pow_right₀ ( by decide ) ( Nat.sub_le _ _ ) )